<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Clase 1: Distribución, abundancia, riqueza de especies y modelos jerárquicos en ecología</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Clase1_files/libs/clipboard/clipboard.min.js"></script>
<script src="Clase1_files/libs/quarto-html/quarto.js"></script>
<script src="Clase1_files/libs/quarto-html/popper.min.js"></script>
<script src="Clase1_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Clase1_files/libs/quarto-html/anchor.min.js"></script>
<link href="Clase1_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Clase1_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Clase1_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Clase1_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Clase1_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Clase 1: Distribución, abundancia, riqueza de especies y modelos jerárquicos en ecología</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>En esta primera clase, discutiremos los patrones puntuales, los estimadores de abundancia y ocupación en los diseños para estudiar metapoblaciones, sus parámetros y errores en los modelos aplicados a la ecología. Finalmente, profundizaremos en los modelos jerárquicos para estimar la distribución, abundancia y riqueza de especies.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true" href="">Distribución, abundancia y riqueza de especies en ecología</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false" href="">¿QUÉ SON LOS MODELOS JERÁRQUICOS Y CÓMO LOS ANALIZAMOS?</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-3" role="tab" aria-controls="tabset-1-3" aria-selected="false" href="">Actividades</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<p>Referencia:</p>
<p><a href="https://doi.org/10.1016/B978-0-12-801378-6.00001-1">Applied Hierarchical Modeling in Ecology</a></p>
<section id="procesos-puntuales-distribución-abundancia-y-riqueza-de-especies" class="level2">
<h2 class="anchored" data-anchor-id="procesos-puntuales-distribución-abundancia-y-riqueza-de-especies">PROCESOS PUNTUALES, DISTRIBUCIÓN, ABUNDANCIA Y RIQUEZA DE ESPECIES</h2>
<p>La distribución y la abundancia son las dos variables de estado fundamentales en ecología (Begon et al., 1986; Krebs, 2009), y la riqueza de especies es la medida más utilizada para evaluar la biodiversidad (Purvis y Hector, 2000; Balmford et al., 2003). Las tres son el foco de una gran cantidad de estudios ecológicos teóricos y, especialmente, de estudios centrados en problemas de manejo o conservación específicos que involucran especies raras o en peligro, animales de caza y especies invasoras. Sin embargo, las tres son solo cantidades derivadas, es decir, resúmenes de una cantidad más fundamental: los patrones de puntos. Los patrones de puntos son el resultado de procesos estocásticos conocidos como procesos puntuales y, como es de esperar, los modelos estadísticos que los describen se llaman modelos de procesos puntuales (PPM; Illian et al., 2008; Wiegand y Moloney, 2014). Los PPM tratan tanto el número como las ubicaciones de puntos discretos como cantidades aleatorias regidas por un campo de intensidad subyacente y continuo. La intensidad es el número esperado de puntos (por ejemplo, animales o plantas) por unidad de área en algún área de estudio y es el parámetro modelado.</p>
<p>Tanto la distribución como la abundancia son resúmenes espaciales simples de patrones de puntos para una especie animal o vegetal, es decir, agregaciones de un patrón de puntos en alguna área. Para desarrollar una comprensión básica de las relaciones entre un patrón de puntos, la abundancia y la ocurrencia, realizaremos una primera simulación de datos sencilla en el programa R.</p>
<p>La función <code>sim.fn</code> permite experimentar con la relación entre un patrón de puntos, la abundancia y la ocurrencia en función de la intensidad del patrón (que es algo que no se puede controlar en la vida real y es el resultado de la biología) y del tamaño de la cuadrícula, o más específicamente, el tamaño de las celdas que componen esa cuadrícula; esto es algo que puedes ajustar.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(AHMbook)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">sim.fn</span>(<span class="at">quad.size =</span> <span class="dv">10</span>, <span class="at">cell.size =</span> <span class="dv">1</span>, <span class="at">intensity =</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>$quad.size
[1] 10

$cell.size
[1] 1

$intensity
[1] 1

$exp.N
[1] 100

$breaks
 [1]  0  1  2  3  4  5  6  7  8  9 10

$n.cell
[1] 100

$mid.pt
 [1] 0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5

$M
[1] 98

$u1
 [1] 9.6747481 0.5600180 8.6421493 2.6040846 6.2159176 7.5469158 5.4175551
 [8] 5.3262167 6.8489597 3.6992375 3.1150337 1.6943543 8.4120278 0.8351315
[15] 5.4851800 1.6801517 4.5054292 0.3567548 2.6543775 3.4023373 9.2553302
[22] 4.2592710 5.6600599 7.9888794 8.3392539 4.3258706 6.0557237 4.2598526
[29] 3.6320446 8.2456905 2.2782948 4.1479985 3.3568512 6.2719069 9.6522068
[36] 0.2633407 9.6574681 6.1203302 3.3445880 0.8945236 4.0250224 2.8599465
[43] 8.7808829 9.9133834 5.8799242 2.4585867 0.8696410 4.6027617 6.3774822
[50] 3.0631329 7.1605878 3.4948714 0.7499810 1.9123972 9.2006248 8.3038745
[57] 6.4734064 3.7500651 9.4558940 3.7648969 2.2738776 4.9182861 5.9719964
[64] 2.5242295 0.6513484 2.6543188 8.1857640 4.3672033 2.3234256 3.0794531
[71] 4.0571587 9.8784046 8.6410596 2.9529055 8.3105000 8.8657193 3.3334765
[78] 6.0815276 9.2782648 1.2830231 0.4891028 5.4461121 6.4545011 6.7429593
[85] 9.3600138 5.1073215 5.2616215 7.7637151 3.3072955 3.5837728 0.3254906
[92] 8.8883921 0.2381907 1.3663289 0.1780140 9.1483421 0.4284172 7.2503288

$u2
 [1] 2.96747999 0.05300952 1.68054615 9.15081356 6.89113559 5.03107382
 [7] 5.84739345 3.05629783 3.81123410 2.07844040 2.86179697 8.41831009
[13] 2.25533582 1.53599347 1.93611739 7.28501726 3.75492440 9.57928847
[19] 5.64364931 8.06710410 1.49476416 5.53527423 2.09868488 8.01182694
[25] 0.71444213 9.36719288 6.82725866 2.50377980 4.74446169 6.83726124
[31] 5.82293625 7.00404827 6.17012469 0.28979221 0.67225365 1.69957006
[37] 9.35645873 2.61105851 8.21535190 1.92327274 0.84011007 4.04194865
[43] 0.06079161 5.93121184 6.60422862 0.15864373 5.75213541 6.40889766
[49] 9.78348062 0.54647891 7.44817405 7.30492677 8.79212508 9.02698260
[55] 8.23629032 9.51377691 6.65302896 8.20506731 4.59053164 4.12623290
[61] 1.60891189 3.53848659 4.08845603 1.11511889 7.11639702 4.96105915
[67] 0.45907384 4.24438820 9.50042360 8.31159038 2.46295351 1.79985506
[73] 6.32087535 8.82676217 6.83265032 8.85931579 0.07392735 2.28309054
[79] 8.74348987 0.77748643 2.65761370 9.07936483 0.30318571 3.86161259
[85] 1.86465140 5.60705211 1.14860896 2.44202457 3.57426132 0.36107336
[91] 8.39223494 7.61211277 0.27507456 0.19468631 2.90176083 8.45568254
[97] 3.58341193 6.42481176

$N
        
         (0,1] (1,2] (2,3] (3,4] (4,5] (5,6] (6,7] (7,8] (8,9] (9,10]
  (0,1]      2     3     2     1     0     1     0     1     2      1
  (1,2]      2     0     0     0     0     0     0     1     1      1
  (2,3]      1     2     0     0     2     2     0     0     1      2
  (3,4]      3     0     2     1     2     0     1     1     4      0
  (4,5]      1     0     2     2     1     1     1     1     0      1
  (5,6]      0     2     1     1     1     2     1     0     0      1
  (6,7]      2     0     2     2     0     0     3     0     0      1
  (7,8]      0     0     1     0     0     1     1     1     1      0
  (8,9]      3     1     1     0     0     0     3     1     1      1
  (9,10]     1     3     1     0     1     1     0     0     3      1

$z
        
         (0,1] (1,2] (2,3] (3,4] (4,5] (5,6] (6,7] (7,8] (8,9] (9,10]
  (0,1]      1     1     1     1     0     1     0     1     1      1
  (1,2]      1     0     0     0     0     0     0     1     1      1
  (2,3]      1     1     0     0     1     1     0     0     1      1
  (3,4]      1     0     1     1     1     0     1     1     1      0
  (4,5]      1     0     1     1     1     1     1     1     0      1
  (5,6]      0     1     1     1     1     1     1     0     0      1
  (6,7]      1     0     1     1     0     0     1     0     0      1
  (7,8]      0     0     1     0     0     1     1     1     1      0
  (8,9]      1     1     1     0     0     0     1     1     1      1
  (9,10]     1     1     1     0     1     1     0     0     1      1

$psi
[1] 0.64</code></pre>
</div>
</div>
<p>La función simula ubicaciones de animales o plantas en una cuadrícula de celdas que forma un cuadrante con un tamaño total (unidades totales) igual a <code>quad.size</code>, según un proceso de Poisson en el que los individuos se distribuyen al azar en el espacio. Este proceso se caracteriza por una intensidad, o número esperado de plantas o animales (“puntos”) por unidad de área. El patrón de puntos resultante se discretiza superponiendo una cuadrícula con celdas cuadradas de longitud <code>cell.size</code>. Esta discretización del espacio es lo que permite definir la abundancia en primer lugar y, luego, la presencia/ausencia o ocurrencia. La riqueza de especies, la tercera cantidad crucial mencionada en el título, es la suma de especies que ocurren en un sitio, lo que representa un resumen de los patrones de puntos, no para una sola especie, sino para un conjunto de especies presentes en un sitio.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">82</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>tmp <span class="ot">&lt;-</span> <span class="fu">sim.fn</span>(<span class="at">quad.size =</span> <span class="dv">16</span>, <span class="at">cell.size =</span> <span class="dv">2</span>, <span class="at">intensity =</span> <span class="fl">0.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>En esta simulación, un “sitio” está representado por una celda en toda la cuadrícula. Tal vez puedas imaginar la cuadrícula completa como una región en la que se lleva a cabo tu estudio. Solo una vez que hemos establecido esa discretización del espacio, podemos definir la abundancia (que nos gusta denotar como <em>N</em>) o la ocurrencia (presencia/ausencia) la cual nos gusta denotar como <em>z</em>). Luego, la abundancia <em>N</em> es simplemente el número de puntos que caen en cada “sitio” (es decir, celda): si no hay puntos en una celda, la abundancia es cero; si hay un punto, la abundancia es uno; y así sucesivamente. Además, la presencia/ausencia (<em>z</em>) distingue los dos casos en los que no hay puntos en una celda (es decir, <em>N</em> = <em>0</em>, lo cual representa una ausencia o no ocurrencia) o en los que hay uno o más puntos en la celda (es decir, <em>N</em> &gt; <em>0</em>, lo cual representa una presencia u ocurrencia). Así, podemos decir que la abundancia es un primer paso en la agregación de un patrón de puntos subyacente dentro de un esquema de discretización espacial, y la ocurrencia es un segundo paso en esta agregación sobre las unidades espaciales.</p>
<p>Alternativamente, podemos decir que la ocurrencia es un resumen simplificado y con poca información de la abundancia, donde solo se registran dos clases de abundancia: una siendo cero (=“ausencia”) y la La otra clase mayor a cero (= “presencia”). Así, las relaciones entre un patrón de puntos, abundancia y ocurrencia son determinísticas en un solo sentido: si se conoce el patrón completo y se tiene un esquema de discretización espacial, también se tiene conocimiento completo sobre la abundancia; y si se conoce el patrón espacial de abundancia, también se conoce perfectamente el patrón espacial de ocurrencia. En cambio, el proceso inverso no es tan directo; por ejemplo, al conocer solo un patrón de presencia/ausencia, no puedes inferir perfectamente la distribución subyacente de abundancia, aunque puedes hacer inferencias estadísticas explícitas (He y Gaston, 2000; Royle et al., 2003; Ramsey et al., 2015).</p>
</section>
<section id="diseños-de-meta-poblaciones" class="level2">
<h2 class="anchored" data-anchor-id="diseños-de-meta-poblaciones">DISEÑOS DE META-POBLACIONES</h2>
<p>Curiosamente, sin conocer la relación entre los procesos puntuales y sus abundancias y ocurrencias interrelacionadas, a las personas siempre les ha gustado discretizar su área de estudio completa en subunidades más pequeñas, o, dicho de otra manera, replicar sus áreas de estudio en el espacio. Esto da lugar a lo que llamamos un “diseño de meta-población” (Royle, 2004a; Kéry y Royle, 2010). <em>“Somos un tanto cautelosos con este término porque no queremos implicar que los animales que viven en tales unidades espaciales discretas necesariamente se comportan según una metapoblación formal (Hanski, 1998; Sutherland et al., 2012, 2014). Más bien, no pudimos encontrar un término mejor y más conciso para el caso extremadamente común en el que se estudia la distribución o abundancia en una colección de sitios espacialmente replicados o donde toda un área de estudio se subdivide en subunidades más pequeñas, a las que típicamente llamamos sitios”</em> (kery and Royle, 2016).</p>
<p>Tales diseños de meta-población, o diseños con poblaciones espacialmente subdivididas, son extremadamente comunes en ecología y todas las ciencias relacionadas. Además, se adoptan prácticamente en todas partes en el monitoreo biológico, donde está claro que no se puede caracterizar el estado del medio ambiente solo con mediciones tomadas en un único sitio. Los diseños de meta-población vienen en una gran variedad, y el número, tamaño y forma de las celdas (subunidades) pueden variar, uno de ellos es el submuestreo espacial es sorprendentemente común en los diseños de meta-población, en los cuales cada sitio (unidad) se subdivide aún más en subunidades espaciales más pequeñas, que nuevamente pueden cubrir todo el sitio o solo una parte del área total de un sitio.</p>
</section>
<section id="parámetros-de-estado-y-de-tasa" class="level2">
<h2 class="anchored" data-anchor-id="parámetros-de-estado-y-de-tasa">PARÁMETROS DE ESTADO Y DE TASA</h2>
<p>La abundancia, distribución y riqueza de especies son, quizás, las variables más estudiadas en toda la ecología y campos relacionados. Sin embargo, con mucha frecuencia hay un interés no solo en estas variables de estado, sino también en los parámetros que gobiernan la tasa de cambio de estas cantidades, es decir, que impulsan la dinámica de las poblaciones (variables de tasa). Por ejemplo, la cantidad más importante en el monitoreo de biodiversidad parece ser la “tendencia”, es decir, una tasa sostenida de cambio a lo largo del tiempo de alguna cantidad como la abundancia u ocurrencia. Y una tendencia es solo la descripción más simple de la dinámica de la población; la descripción más detallada de la dinámica de una población animal se logra mediante las cuatro tasas vitales: tasa de natalidad, tasa de inmigración, tasa de mortalidad y tasa de emigración, y estas pueden ser estratificadas por edad, sexo o posiblemente otras clases en una población de estudio.</p>
<p>Una tasa vital que ha recibido un interés particular en la ecología animal y otros campos, como la evolución de la historia de vida (Stearns, 1992), es la probabilidad de supervivencia. Existen teorías bien desarrolladas para estimar la supervivencia a partir de muestras temporales replicadas de animales salvajes marcados, por ejemplo, en el célebre modelo de Cormack-Jolly-Seber (Cormack, 1964; Jolly, 1965; Seber, 1965; Pollock et al., 1990), en su variante para datos de recuperación de anillos (Brownie et al., 1985) y en una multitud de generalizaciones, incluidos los modelos multiestados (Arnason, 1972; Hestbeck et al., 1991; Brownie et al., 1993; Arnason y Schwarz, 1999) y modelos relacionados (Barker, 1997; Pradel et al., 1997; Kendall et al., 2003; Pradel, 2005; Bonner y Schwarz, 2006).</p>
<p>En ecología animal existe una división bastante marcada entre los modelos y métodos (y curiosamente también entre las personas que aplican estos modelos) que se centran en las variables de estado (por ejemplo, estimar abundancia) o que se enfocan en las variables de tasa (por ejemplo, estimar supervivencia). Esta división es en su mayoría artificial y en gran parte se debe a las limitaciones de los modelos pasados y actuales, así como del software asociado para ajustar estos modelos. Por lo tanto, hasta hace muy poco, existía una gran división en las estadísticas ecológicas entre los modelos para “poblaciones cerradas” (lo que esencialmente significaba estimación de abundancia) y los modelos para “poblaciones abiertas” (lo que, ante todo, significaba estimación de supervivencia). Sin embargo, hoy en día, esta distinción se difumina cada vez más y, especialmente en el contexto de los modelos jerárquicos, se puede ver cuán fácilmente podemos unir lo que hace solo 10 años podría haberse considerado una división profunda. Además, la facilidad con la que podemos ajustar “modelos híbridos abiertos/cerrados” a nuestros datos se debe en gran parte al poder de la maquinaria de ajuste de modelos bayesianos y, en la práctica, al software BUGS (Schofield et al., 2009). Esto es especialmente interesante también para la el modelado de dinámicas poblacionales, como el análisis de viabilidad poblacional (Beissinger, 2002) y la modelización poblacional relacionada (Bockland et al., 2004b, 2007; Schofield y Barker, 2008; Tavecchia et al., 2009; Newman et al., 2006, 2014), incluyendo los modelos de proyección matricial (Caswell, 2001; Link et al., 2003). Finalmente, otro tipo de modelo poblacional en el que la división entre poblaciones abiertas y cerradas se elimina por completo es el fascinante campo de la modelización integrada de poblaciones (IPMs, Baillie, 1991; Besbeas et al., 2002; Brooks et al., 2004; Schaub et al., 2007; Abadi et al., 2010a,b; Schaub y Abadi, 2011).</p>
</section>
<section id="modelos-de-error-de-medición-en-ecología" class="level2">
<h2 class="anchored" data-anchor-id="modelos-de-error-de-medición-en-ecología">MODELOS DE ERROR DE MEDICIÓN EN ECOLOGÍA</h2>
<p>El error en una medición es la diferencia entre el valor medido y el valor verdadero de alguna cantidad. Probablemente, el tipo de error de medición más conocido en ecología sea el relacionado con la medición de cantidades continuas, como el tamaño corporal, la masa corporal o el contenido de algún contaminante en el aire o el agua. Su medición está probablemente afectada por una gran cantidad de pequeñas causas que actúan de manera aditiva, dando lugar a errores de medición que típicamente siguen una distribución normal. Una consecuencia importante de esto es que las mediciones son imparciales, es decir, en promedio están en el objetivo; los errores positivos y negativos simplemente se cancelan entre sí en el promedio de mediciones repetidas. Este tipo de error de medición parece ser el que la gente tiene en mente cuando piensa en este tema en ecología. Por ejemplo, este tipo de error de medición generalmente se maneja en el residuo de un modelo de regresión.</p>
<p>Sin embargo, las cosas son muy diferentes para los conteos de variables discretas como la abundancia, y esto incluye la variable binaria “presencia/ausencia”, es decir, cuando se trata de la agregación de datos de un proceso puntual subyacente. Para ellas, puede haber subestimaciones y sobreestimaciones, y los mecanismos que conducen a los dos tipos de errores no son los mismos, sino que pueden ser muy diferentes. Así, existe un conjunto de mecanismos que lleva a errores falsos negativos, cuando se pasa por alto a un individuo o se omite una especie en un sitio donde ocurre. Este tipo de error no puede describirse razonablemente con una distribución normal, sino que típicamente se describe mediante una distribución binomial o una distribución de Bernoulli. Dado que hay <em>N</em> individuos presentes y existe alguna probabilidad p de detectar a cada uno de ellos, el número de individuos detectados (<em>C</em>) será binomial:</p>
<p><span class="math display">\[ C \sim \text{Binomial}(N, p) \]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Modelo de error de medición falso negativo para conteos</p>
</div>
</div>
<p>Aquí, p es la probabilidad de detección o encuentro de un individuo y representa el complemento de la tasa de error falso negativo, es decir, la tasa de error asociada es <em>1-p</em>. De manera similar, para el estado de presencia/ausencia de una especie en un sitio, <em>z</em>, donde <em>z</em> = 1 denota presencia y <em>z</em> = 0 denota ausencia, podemos especificar el siguiente modelo de error de medición para la medición de presencia/ausencia o para el dato de detección/no detección en un sitio ocupado:</p>
<p><span class="math display">\[ y \sim \text{Bernoulli}(p) \]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Modelo de error de medición falso negativo para observaciones de detección/no detección.</p>
</div>
</div>
<p>En cualquiera de los casos, y a diferencia del modelo normal para errores de medición con variables continuas, el promedio de mediciones repetidas no será imparcial con respecto a las cantidades objetivo (<em>N</em> de abundancia o presencia/ausencia). Más bien, el promedio será igual a <em>Np</em> para los conteos y igual a <em>p</em> para las mediciones de presencia/ausencia (observaciones de detección/no detección) en un sitio ocupado. En contraste, el máximo entre una serie de mediciones se acercará cada vez más a los valores verdaderos <em>N</em> o <em>z</em> a medida que se aumente el número de mediciones repetidas, y qué tan rápido se acerca el máximo a <em>N</em> depende nuevamente de la probabilidad de detección <em>p</em>.</p>
</section>
<section id="error-falso-negativo-y-falso-positivo" class="level2">
<h2 class="anchored" data-anchor-id="error-falso-negativo-y-falso-positivo">ERROR FALSO-NEGATIVO y FALSO-POSITIVO</h2>
<p>El error de detección de falsos negativos, es el error de detección que se aborda en la gran mayoría de los métodos de captura-recaptura y métodos relacionados. En la base de prácticamente todos estos métodos está el modelo de error de medición binomial o de Bernoulli. Se podría argumentar que los errores de falsos negativos ocurren en casi todos los conjuntos de datos sobre distribución y abundancia, ya sea para animales o plantas.</p>
<p>Además de los errores de falsos negativos, también podemos tener errores de falsos positivos. Por ejemplo, en términos de abundancia, podríamos sobrecontar, generalmente porque contamos al mismo individuo varias veces o porque confundimos una especie con otra. En términos de ocurrencia, esto significa que creemos haber detectado una especie en un sitio donde en realidad no ocurre o que creemos haberla detectado en un sitio donde sí ocurre, pero lo que observamos no era la especie objetivo; revisar <a href="https://doi.org/10.1890/14-1507.1">Chambert et al.&nbsp;(2015)</a> para más detalles sobre esta distinción.</p>
<p>Cuando tratamos con datos resumidos en áreas discretizadas a partir de patrones de puntos “simples”, es decir, datos de abundancia u ocurrencia, estos son los dos tipos fundamentales de errores de medición. Sin embargo, además, existen errores de clasificación de estado cuando clasificamos individuos por edad, tamaño u otros estados, como en los modelos de estados múltiples y cuando distinguimos entre diferentes tipos de “ocurrencia”, como la de individuos no reproductivos frente a la de individuos reproductivos, como en los modelos de ocupación de estados múltiples.</p>
<p>Cuando trabajamos directamente con los datos del patrón de puntos subyacente, surge un tercer tipo fundamental de error: el error de localización. Es decir, una diferencia entre las coordenadas reales en las que se encuentra un individuo cuando lo detectamos y las coordenadas que registramos e introducimos en nuestro modelo. El error de localización debe abordarse en modelos espacialmente explícitos para abundancia o densidad porque, de lo contrario, se obtienen estimadores sesgados. El marco de modelado espacialmente explícito más simple para abundancia, el muestreo por distancia convencional, elimina el problema al requerir como uno de sus principales supuestos que el error de localización sea nulo. Curiosamente, una vez que “olvidamos” las ubicaciones individuales al agregar un patrón de puntos para convertirlo en datos de abundancia u ocurrencia, el error de localización “desaparece” y se traduce en errores de falsos positivos o falsos negativos. Si el error de localización hace que un individuo se registre erróneamente en una celda vecina, entonces ese registro se convierte en un falso positivo en esa celda y corresponderá a un falso negativo en la celda donde realmente se encuentra el individuo. Si el error de localización no lleva al registro del individuo en una celda diferente de aquella donde realmente está, no tiene consecuencias en el modelado de la abundancia o ocurrencia.</p>
<p>En ecología, hay otro tipo de error de medición: el que ocurre en las covariables. Este es bastante diferente de los otros tipos de errores de medición mencionados en esta sección, que están asociados con la respuesta en un modelo, no con una covariable en el modelo. El problema de los errores en covariables en modelos de distribución y abundancia es exactamente análogo al de cualquier otro modelo de regresión. Esencialmente, los errores de medición en covariables continuas atenúan la estimación de la pendiente, es decir, hacen que la estimación erróneamente se acerque a cero. Existe una cantidad considerable de literatura estadística sobre este tipo de error de medición <a href="https://www.tandfonline.com/doi/abs/10.1080/01621459.2000.10474347">(Stefanski, 2000)</a>.</p>
<p>Por lo tanto, generalmente no es suficiente que un modelo ecológico de distribución y abundancia simplemente describa la variabilidad espacial de un proceso y posiblemente también las dinámicas temporales en la abundancia u ocurrencia. Más bien, para lograr inferencias no sesgadas sobre la demografía de la distribución y la abundancia, será necesario modelar explícitamente los procesos de error de medición que subyacen a los datos disponibles. Los estudios que emplean diseños de metapoblación suelen enfrentar dos pasos inferenciales secuenciales (ver Figura 1.1). <img src="booksPictures/Figure1.png" class="img-fluid"> Figura 1.1: Los dos procesos de muestreo en ecología que típicamente subyacen a la medición de la abundancia o la ocurrencia son: primero, el muestreo espacial y, luego, la medición de la cantidad deseada. <em>N</em> y <em>z</em> denotan las cantidades típicas de interés (abundancia y presencia/ausencia, respectivamente), mientras que <em>C</em> e <em>y</em> representan sus mediciones, ya sea un conteo o una medición de detección/no detección, respectivamente.</p>
<p>El primero es desde la muestra de sitios muestreados hacia una “población” estadística más amplia de sitios en los que estamos interesados. Necesitamos un modelo estadístico para describir la variabilidad entre estos sitios y el muestreo de los sitios relevados para inferir cantidades en toda la región. Y, en segundo lugar, necesitamos otro modelo estadístico para describir la aleatoriedad en el proceso de medición, típicamente para estimar y, por lo tanto, corregir las tasas de error de falsos negativos y falsos positivos. Este procedimiento de muestreo en dos pasos es ubicuo en la ecología y especialmente en el monitoreo de biodiversidad.</p>
</section>
<section id="modelos-jerárquicos-para-distribución-abundancia-y-riqueza-de-especies" class="level2">
<h2 class="anchored" data-anchor-id="modelos-jerárquicos-para-distribución-abundancia-y-riqueza-de-especies">MODELOS JERÁRQUICOS PARA DISTRIBUCIÓN, ABUNDANCIA Y RIQUEZA DE ESPECIES</h2>
<p>Los modelos jerárquicos son una secuencia de modelos de probabilidad ordenados según su estructura de probabilidad condicional, lo que implica que describen variables aleatorias condicionalmente dependientes. En el contexto de los modelos descritos y analizados en este curso, utilizaremos modelos jerárquicos para representar tanto el verdadero estado de la naturaleza, que no es observable (o solo parcialmente observable), como los errores de medición.</p>
<p>Típicamente, nuestros modelos jerárquicos incluyen un submodelo para el estado verdadero de interés y otro para los errores de medición, aunque en algunos casos puede haber más de un submodelo para cualquiera de estos aspectos. En el caso más común, donde el modelo aborda únicamente errores de detección falsos negativos, el nivel “inferior” del modelo jerárquico (donde se encuentran los datos) es una distribución binomial (o Bernoulli) donde la “probabilidad de éxito” se interpreta como la probabilidad de detección. En cierto sentido, esto convierte a la mayoría de los modelos presentados en este curso en una versión sofisticada de una regresión logística, pero con estructuras de efectos aleatorios posiblemente muy complejas. Otros aspectos del patrón espacio-temporal de ocurrencia o abundancia, o de cómo observamos esos patrones, pueden ser representados mediante niveles adicionales en el modelo, especialmente agrupaciones por sitio, especie, etc.</p>
<p>Los modelos jerárquicos son una herramienta para realizar inferencias sobre distribución, abundancia, riqueza de especies y otras cantidades demográficas relacionadas en poblaciones, metapoblaciones, comunidades y metacomunidades. Son ideales para integrar, en un solo modelo, múltiples conjuntos de datos, múltiples fuentes de variabilidad (espacial, temporal y espacio-temporal) y múltiples escalas de medición. Además, permiten propagar rigurosamente la incertidumbre combinada hacia cada estimación derivada del modelo. Su implementación en un marco Bayesiano con métodos de cadenas de Markov Monte Carlo (MCMC) ofrece una potencia casi ilimitada para su aplicación a datos reales.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>La implementación en un marco Bayesiano con métodos de cadenas de Markov Monte Carlo (MCMC) solo se desarollará en la clase de supervicenvia relativa.</p>
</div>
</div>
<p>Adicionalmente, los modelos jerárquicos representan una “compartimentalización” natural de un sistema grande y complejo en una secuencia de subsistemas más pequeños y, por lo general, mucho menos complejos. (De hecho, el término “modelos secuenciales” podría ser igualmente adecuado para describirlos). Este es un marco ideal para describir conjuntamente el verdadero estado y dinámica de un sistema subyacente de interés, como una población de animales o plantas, o una metapoblación, y los procesos de medición potencialmente complejos con diversos tipos de error, posiblemente heterogéneos.</p>
</section>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<p>Referencia:</p>
<p><a href="https://doi.org/10.1016/B978-0-12-801378-6.00001-1">Applied Hierarchical Modeling in Ecology</a></p>
<p>En este apartado proporcionamos una definición conceptual del término modelo jerárquico tal como lo utilizamos a lo largo del curso. Usamos este término para describir un conjunto acoplado de modelos ordinarios (o “planos”) que están relacionados condicionalmente entre sí. Por condicional nos referimos al sentido de probabilidad condicional: la distribución de probabilidad de una variable aleatoria depende de otra variable aleatoria, generalmente expresada como <em>f(y∣z</em>) o <em>[y∣z*], lo que indica que las probabilidades de los resultados de la variable aleatoria y dependen del resultado de la variable aleatoria </em>z*.</p>
<p>Típicamente, los modelos contienen un componente para las observaciones o datos y uno o más componentes adicionales para describir variables latentes o resultados de algún proceso ecológico. <em>“Aunque nuestro uso del término modelo jerárquico es algo más específico que en la literatura estadística, consideramos que sirve para proporcionar una unificación conceptual de muchos tipos diferentes de modelos, como los modelos de ocupación <a href="https://doi.org/10.1890/0012-9658(2002)083%5B2248:ESORWD%5D2.0.CO;2">(MacKenzie et al., 2002)</a>, modelos N-mixture <a href="https://doi.org/10.1111/j.0006-341X.2004.00142.x">(Royle, 2004b)</a>, muestreo por distancias (<a href="https://doi.org/10.1890/03-3127">Royle et al., 2004</a>; <a href="https://doi.org/10.1890/11-1400.1">Sillett et al., 2012</a>), y muchos otros”</em> (Kéry y Royle 2016).</p>
<p>En el transcurso del curso los temas principales se aboradaran en el análisis de modelos jerárquicos utilizando métodos de inferencia clásica y algunos en bayesiana. Algunos problemas se resuelven más fácilmente, o únicamente, mediante análisis bayesiano con métodos de Markov Canenas de Monte Carlo (MCMC), mientras que otros problemas se resuelven mejor utilizando métodos de verosimilitud clásica. Por ejemplo, los modelos con efectos aleatorios espacialmente correlacionados no pueden analizarse fácilmente con métodos clásicos de verosimilitud, mientras que muchos modelos estándar de mezcla discreta, como los modelos N-mixture, se analizan fácilmente con métodos de verosimilitud, lo que permite realizar selecciones de modelos basadas en el criterio de información de Akaike (AIC).</p>
<p>¿Qué entendemos por “inferencia clásica”? Estrictamente hablando, nos referimos al análisis directo de la verosimilitud, por ejemplo, a la estimación de parámetros mediante máxima verosimilitud. También incluye la perspectiva conceptual de la inferencia frecuentista, en la cual las propiedades de los estimadores y los procedimientos se evalúan promediando sobre posibles realizaciones de los datos. Esto implica que la estimación por verosimilitud se interpreta considerando la consistencia de las estimaciones de máxima verosimilitud (MLEs) o la interpretación de intervalos de confianza.</p>
<p>La inferencia bayesiana es cada vez más familiar para los ecólogos. La diferencia principal entre la inferencia bayesiana y la clásica radica en cómo se utilizan las variables aleatorias para formular modelos. En particular, la inferencia clásica considera los parámetros como cantidades fijas pero desconocidas, mientras que la inferencia bayesiana considera los parámetros como variables aleatorias con una distribución previa, lo que permite basar la inferencia en la distribución posterior, es decir, en la distribución de probabilidad del parámetro desconocido dado los datos.</p>
<section id="modelos-estadísticos" class="level2">
<h2 class="anchored" data-anchor-id="modelos-estadísticos">MODELOS ESTADÍSTICOS</h2>
<p>En la mayoría de los modelos estadísticos, una respuesta medida se trata como una variable aleatoria dotada de una función de densidad de probabilidad (pdf, por sus siglas en inglés) que se asume conocida. Por lo tanto, un modelo estadístico para los datos observados se representa mediante una pdf. La pdf incorpora tanto la aleatoriedad (la parte impredecible) en la respuesta como la tendencia de algunos valores a ocurrir con mayor frecuencia que otros, es decir, la parte de la respuesta que es predecible, al menos en un sentido promedio. Casi siempre, tenemos algunas otras variables que asumimos causan parte de la variabilidad en la respuesta, o al menos están asociadas con la respuesta de una manera estocásticamente predecible. En el modelo estadístico, los parámetros básicos de la pdf se reemplazan por alguna función lineal o no lineal de estas covariables.</p>
</section>
<section id="inferencia-estadística" class="level2">
<h2 class="anchored" data-anchor-id="inferencia-estadística">INFERENCIA ESTADÍSTICA</h2>
<p>Un uso importante de la probabilidad, es proporcionar una descripción de los sistemas naturales utilizando variables aleatorias y distribuciones de probabilidad. Más específicamente, en este curso nos centramos en usar variables aleatorias para describir los resultados de procesos ecológicos (observados y no observados) y distribuciones de probabilidad como modelos de la variabilidad en estos posibles resultados. Por lo tanto, la probabilidad forma nuestra base conceptual para el modelado en ecología.</p>
<p>Por otro lado, el campo de la estadística se ocupa del problema fundamental de aprender sobre los parámetros de las distribuciones de probabilidad a partir de los resultados observados (es decir, “datos”) de alguna variable. Los dos paradigmas dominantes de la inferencia estadística, el Bayesiano y el clásico, comparten un vínculo conceptual común al ser enfoques distintos de la inferencia paramétrica. Esto significa que ambos requieren que hagamos suposiciones explícitas sobre el modelo de probabilidad de las variables aleatorias que describen nuestro sistema. Cualquiera de los paradigmas procede entonces a realizar alguna tarea de inferencia (estimación, predicción, selección de modelos, pruebas) que asume que dichas suposiciones paramétricas son ciertas.</p>
</section>
<section id="hierarchical-models-hms" class="level2">
<h2 class="anchored" data-anchor-id="hierarchical-models-hms">HIERARCHICAL MODELS (HMs)</h2>
<p>Como una definición muy general, podemos decir que un modelo jerárquico (HM), es una secuencia de modelos relacionados ordenados según su estructura de probabilidad condicional. En términos prácticos, esto significa que los HMs tienen uno o más niveles “intermedios” que involucran una variable latente (o efecto aleatorio). Según esta definición, los modelos clásicos de efectos aleatorios son claramente HMs. Por ejemplo, imaginemos una encuesta en un conjunto de unidades espaciales <em>i</em>=1,2,…,<em>M</em>, en las cuales tomamos <em>j</em>=1,2,…<em>J</em> observaciones replicadas <em>yij</em> de alguna medición ecológica. Naturalmente, podríamos suponer que las mediciones replicadas en la misma unidad son más similares entre sí que aquellas tomadas entre diferentes unidades, y esta es la motivación estándar para incluir un efecto de grupo aleatorio α. Por lo tanto, podríamos especificar el modelo para las observaciones de la siguiente manera:</p>
<p><span class="math display">\[y_{ij}\mid \alpha_i \sim \text{Normal}(\mu + \alpha_i, \sigma^2)\]</span></p>
<p>donde el efecto aleatorio también tiene una distribución como:</p>
<p><span class="math display">\[\alpha_i\sim \text{Normal}(0, \sigma^2_\alpha)\]</span></p>
<p>Es importante notar que enfatizamos la dependencia condicional de <em>yij</em> en <em>αi</em> al expresar el modelo para <em>yij</em>. En una notación abreviada, usamos corchetes como <em>[y∣α*]</em> para representar el modelo de observación, donde la barra vertical indica la dependencia condicional explícita de una variable (<em>y</em> en este caso) en otra (<em>α</em> en este caso), <em>y [α]</em> representa el modelo para el efecto aleatorio. El HM es, por lo tanto, el par de submodelos <em>[y∣α]</em> y <em>[α]</em>.</p>
<p>Es importante señalar que no siempre hay una “jerarquía” lógica de arriba hacia abajo involucrada en un modelo jerárquico, como cuando modelamos individuos anidados dentro de poblaciones, etc. En este sentido, un término igualmente válido (o quizás incluso más adecuado) podría ser “modelo secuencial” (SM) en lugar de modelo jerárquico. Sin embargo, dado que el término “modelo jerárquico” es tan común, no lo cambiaríamos.</p>
</section>
<section id="modelos-jerárquicos-canónicos-en-ecología" class="level2">
<h2 class="anchored" data-anchor-id="modelos-jerárquicos-canónicos-en-ecología">Modelos Jerárquicos Canónicos en Ecología:</h2>
<ol type="1">
<li><p>El modelo de ocupación para distribuciones de especies</p></li>
<li><p>El modelo N-Mixture para abundancia</p></li>
</ol>
</section>
</div>
<div id="tabset-1-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-3-tab">
<ul>
<li><ol type="1">
<li>Instalar el paquete <code>unmarked</code>, <code>jagsUI</code>, <code>MuMIn</code>, <code>AICcmodavg</code></li>
</ol></li>
<li><ol start="2" type="1">
<li>Ejecutar los siguientes comandos</li>
</ol></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(unmarked)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">35</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>nSites <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>nVisits <span class="ot">&lt;-</span> <span class="dv">3</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(nSites)               <span class="co"># a covariate</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>beta0 <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>beta1 <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>lambda <span class="ot">&lt;-</span> <span class="fu">exp</span>(beta0 <span class="sc">+</span> beta1<span class="sc">*</span>x)   <span class="co"># expected counts at each site</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="fu">rpois</span>(nSites, lambda)       <span class="co"># latent abundance</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, nSites, nVisits)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.3</span>, <span class="fl">0.6</span>, <span class="fl">0.8</span>)            <span class="co"># detection prob for each visit</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nVisits) {</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  y[,j] <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(nSites, N, p[j])</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Organize data</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>visitMat <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">as.character</span>(<span class="dv">1</span><span class="sc">:</span>nVisits), nSites, nVisits, <span class="at">byrow=</span><span class="cn">TRUE</span>)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>umf <span class="ot">&lt;-</span> <span class="fu">unmarkedFramePCount</span>(<span class="at">y=</span>y, <span class="at">siteCovs=</span><span class="fu">data.frame</span>(<span class="at">x=</span>x),</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="at">obsCovs=</span><span class="fu">list</span>(<span class="at">visit=</span>visitMat))</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(umf)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit a model</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>fm1 <span class="ot">&lt;-</span> <span class="fu">pcount</span>(<span class="sc">~</span>visit<span class="dv">-1</span> <span class="sc">~</span> x, umf, <span class="at">K=</span><span class="dv">50</span>)</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>fm1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plogis</span>(<span class="fu">coef</span>(fm1, <span class="at">type=</span><span class="st">"det"</span>)) <span class="co"># Should be close to p</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>p(visit1) p(visit2) p(visit3) 
0.3504258 0.5840434 0.7787245 </code></pre>
</div>
</div>
<ul>
<li><ol start="3" type="1">
<li>Ejecutar el siguiente comando</li>
</ol></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(jagsUI)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">#Load data (built into R)</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(longley)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(longley)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="co">#Separate data objects</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>gnp <span class="ot">&lt;-</span> longley<span class="sc">$</span>GNP</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>employed <span class="ot">&lt;-</span> longley<span class="sc">$</span>Employed</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">length</span>(employed)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="co">#Input data objects must be numeric, and must be</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="co">#scalars, vectors, matrices, or arrays.</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co">#Package together</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">gnp=</span>gnp,<span class="at">employed=</span>employed,<span class="at">n=</span>n)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="do">######################################</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="do">##      2. Write model file         ##</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="do">######################################</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="co">#Write a model in the BUGS language</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="co">#Generate model file directly in R</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="co">#(could also read in existing model file)</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="co">#Identify filepath of model file</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>modfile <span class="ot">&lt;-</span> <span class="fu">tempfile</span>()</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="co">#Write model to file</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a><span class="fu">writeLines</span>(<span class="st">"</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a><span class="st">model{</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a><span class="st">  #Likelihood</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a><span class="st">  for (i in 1:n){ </span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a><span class="st">    employed[i] ~ dnorm(mu[i], tau)     </span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a><span class="st">    mu[i] &lt;- alpha + beta*gnp[i]</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a><span class="st">  }</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a><span class="st">    </span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a><span class="st">  #Priors</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a><span class="st">  alpha ~ dnorm(0, 0.00001)</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a><span class="st">  beta ~ dnorm(0, 0.00001)</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a><span class="st">  sigma ~ dunif(0,1000)</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a><span class="st">  tau &lt;- pow(sigma,-2)</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a><span class="st">"</span>, <span class="at">con=</span>modfile)</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a><span class="do">######################################</span></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a><span class="do">##    3. Initialize Parameters      ##</span></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a><span class="do">######################################</span></span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a><span class="co">#Best to generate initial values using function</span></span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>inits <span class="ot">&lt;-</span> <span class="cf">function</span>(){  </span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>  <span class="fu">list</span>(<span class="at">alpha=</span><span class="fu">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>),<span class="at">beta=</span><span class="fu">rnorm</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>),<span class="at">sigma=</span><span class="fu">runif</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">3</span>))  </span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a><span class="co">#In many cases, JAGS can pick initial values automatically;</span></span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a><span class="co">#you can leave argument inits=NULL to allow this.</span></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a><span class="do">######################################</span></span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a><span class="do">##  4. Set parameters to monitor    ##</span></span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a><span class="do">######################################</span></span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a><span class="co">#Choose parameters you want to save output for</span></span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a><span class="co">#Only parameters in this list will appear in output object</span></span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a><span class="co">#(deviance is added automatically if DIC=TRUE)</span></span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a><span class="co">#List must be specified as a character vector</span></span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a>params <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">'alpha'</span>,<span class="st">'beta'</span>,<span class="st">'sigma'</span>)</span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a><span class="do">######################################</span></span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a><span class="do">##        5. Run Analysis           ##</span></span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a><span class="do">######################################</span></span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a><span class="co">#Call jags function; specify number of chains, number of adaptive iterations,</span></span>
<span id="cb7-83"><a href="#cb7-83" aria-hidden="true" tabindex="-1"></a><span class="co">#the length of the burn-in period, total iterations, and the thin rate.</span></span>
<span id="cb7-84"><a href="#cb7-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-85"><a href="#cb7-85" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">jags</span>(<span class="at">data =</span> data,</span>
<span id="cb7-86"><a href="#cb7-86" aria-hidden="true" tabindex="-1"></a>            <span class="at">inits =</span> inits,</span>
<span id="cb7-87"><a href="#cb7-87" aria-hidden="true" tabindex="-1"></a>            <span class="at">parameters.to.save =</span> params,</span>
<span id="cb7-88"><a href="#cb7-88" aria-hidden="true" tabindex="-1"></a>            <span class="at">model.file =</span> modfile,</span>
<span id="cb7-89"><a href="#cb7-89" aria-hidden="true" tabindex="-1"></a>            <span class="at">n.chains =</span> <span class="dv">3</span>,</span>
<span id="cb7-90"><a href="#cb7-90" aria-hidden="true" tabindex="-1"></a>            <span class="at">n.adapt =</span> <span class="dv">100</span>,</span>
<span id="cb7-91"><a href="#cb7-91" aria-hidden="true" tabindex="-1"></a>            <span class="at">n.iter =</span> <span class="dv">1000</span>,</span>
<span id="cb7-92"><a href="#cb7-92" aria-hidden="true" tabindex="-1"></a>            <span class="at">n.burnin =</span> <span class="dv">500</span>,</span>
<span id="cb7-93"><a href="#cb7-93" aria-hidden="true" tabindex="-1"></a>            <span class="at">n.thin =</span> <span class="dv">2</span>)</span>
<span id="cb7-94"><a href="#cb7-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-95"><a href="#cb7-95" aria-hidden="true" tabindex="-1"></a><span class="co">#Arguments will be passed to JAGS; you will see progress bars</span></span>
<span id="cb7-96"><a href="#cb7-96" aria-hidden="true" tabindex="-1"></a><span class="co">#and other information</span></span>
<span id="cb7-97"><a href="#cb7-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-98"><a href="#cb7-98" aria-hidden="true" tabindex="-1"></a><span class="co">#Examine output summary</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>out</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>JAGS output for model 'C:\Users\DAVIDM~1\AppData\Local\Temp\RtmpAXtp26\file66ec1d6a7b60', generated by jagsUI.
Estimates based on 3 chains of 1000 iterations,
adaptation = 100 iterations (sufficient),
burn-in = 500 iterations and thin rate = 2,
yielding 750 total samples from the joint posterior. 
MCMC ran for 0.001 minutes at time 2024-11-18 09:42:43.070257.

           mean    sd   2.5%    50%  97.5% overlap0 f  Rhat n.eff
alpha    51.819 0.791 50.267 51.804 53.368    FALSE 1 1.003   405
beta      0.035 0.002  0.031  0.035  0.039    FALSE 1 1.005   319
sigma     0.713 0.148  0.493  0.682  1.057    FALSE 1 1.010   242
deviance 33.328 2.773 30.048 32.702 40.373    FALSE 1 1.006   379

Successful convergence based on Rhat values (all &lt; 1.1). 
Rhat is the potential scale reduction factor (at convergence, Rhat=1). 
For each parameter, n.eff is a crude measure of effective sample size. 

overlap0 checks if 0 falls in the parameter's 95% credible interval.
f is the proportion of the posterior with the same sign as the mean;
i.e., our confidence that the parameter is positive or negative.

DIC info: (pD = var(deviance)/2) 
pD = 3.8 and DIC = 37.161 
DIC is an estimate of expected predictive error (lower is better).</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="HN%20Cursos%20publicidad/HN%20Biology%20Inv%20large.jpg" class="img-fluid figure-img"></p>
<figcaption>HN Biology Investigation Academy</figcaption>
</figure>
</div>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>