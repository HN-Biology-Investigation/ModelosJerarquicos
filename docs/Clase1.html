<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Clase 1: Distribución, abundancia y riqueza de especies en ecología</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Clase1_files/libs/clipboard/clipboard.min.js"></script>
<script src="Clase1_files/libs/quarto-html/quarto.js"></script>
<script src="Clase1_files/libs/quarto-html/popper.min.js"></script>
<script src="Clase1_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Clase1_files/libs/quarto-html/anchor.min.js"></script>
<link href="Clase1_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Clase1_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Clase1_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Clase1_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Clase1_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Clase 1: Distribución, abundancia y riqueza de especies en ecología</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Referencia para la clase 1:</p>
<p><a href="https://doi.org/10.1016/B978-0-12-801378-6.00001-1">Applied Hierarchical Modeling in Ecology</a></p>
<p>En esta primera clase, discutiremos los patrones puntuales, los estimadores de abundancia y ocupación en los diseños para estudiar metapoblaciones, sus parámetros y errores en los modelos aplicados a la ecología. Finalmente, profundizaremos en los modelos jerárquicos para estimar la distribución, abundancia y riqueza de especies.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true" href="">PROCESOS PUNTUALES, DISTRIBUCIÓN, ABUNDANCIA Y RIQUEZA DE ESPECIES</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false" href="">DISEÑOS DE META-POBLACIONES</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-3" role="tab" aria-controls="tabset-1-3" aria-selected="false" href="">PARÁMETROS DE ESTADO Y DE TASA</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-4-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-4" role="tab" aria-controls="tabset-1-4" aria-selected="false" href="">MODELOS DE ERROR DE MEDICIÓN EN ECOLOGÍA</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-5-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-5" role="tab" aria-controls="tabset-1-5" aria-selected="false" href="">ERROR FALSO-NEGATIVO y FALSO-POSITIVO</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-6-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-6" role="tab" aria-controls="tabset-1-6" aria-selected="false" href="">MODELOS JERÁRQUICOS PARA DISTRIBUCIÓN, ABUNDANCIA Y RIQUEZA DE ESPECIES</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<p>La distribución y la abundancia son las dos variables de estado fundamentales en ecología (Begon et al., 1986; Krebs, 2009), y la riqueza de especies es la medida más utilizada para evaluar la biodiversidad (Purvis y Hector, 2000; Balmford et al., 2003). Las tres son el foco de una gran cantidad de estudios ecológicos teóricos y, especialmente, de estudios centrados en problemas de manejo o conservación específicos que involucran especies raras o en peligro, animales de caza y especies invasoras. Sin embargo, las tres son solo cantidades derivadas, es decir, resúmenes de una cantidad más fundamental: los patrones de puntos. Los patrones de puntos son el resultado de procesos estocásticos conocidos como procesos puntuales y, como es de esperar, los modelos estadísticos que los describen se llaman modelos de procesos puntuales (PPM; Illian et al., 2008; Wiegand y Moloney, 2014). Los PPM tratan tanto el número como las ubicaciones de puntos discretos como cantidades aleatorias regidas por un campo de intensidad subyacente y continuo. La intensidad es el número esperado de puntos (por ejemplo, animales o plantas) por unidad de área en algún área de estudio y es el parámetro modelado.</p>
<p>Tanto la distribución como la abundancia son resúmenes espaciales simples de patrones de puntos para una especie animal o vegetal, es decir, agregaciones de un patrón de puntos en alguna área. Para desarrollar una comprensión básica de las relaciones entre un patrón de puntos, la abundancia y la ocurrencia, realizaremos una primera simulación de datos sencilla en el programa R.</p>
<p>La función <code>sim.fn</code> permite experimentar con la relación entre un patrón de puntos, la abundancia y la ocurrencia en función de la intensidad del patrón (que es algo que no se puede controlar en la vida real y es el resultado de la biología) y del tamaño de la cuadrícula, o más específicamente, el tamaño de las celdas que componen esa cuadrícula; esto es algo que puedes ajustar.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(AHMbook)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">sim.fn</span>(<span class="at">quad.size =</span> <span class="dv">10</span>, <span class="at">cell.size =</span> <span class="dv">1</span>, <span class="at">intensity =</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>$quad.size
[1] 10

$cell.size
[1] 1

$intensity
[1] 1

$exp.N
[1] 100

$breaks
 [1]  0  1  2  3  4  5  6  7  8  9 10

$n.cell
[1] 100

$mid.pt
 [1] 0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5

$M
[1] 105

$u1
  [1] 5.3164645 2.1824948 5.0560365 8.4389341 2.7163415 6.1043808 9.9068112
  [8] 2.2750025 8.4141168 0.8042987 0.9632638 7.4467256 7.9625775 5.9630432
 [15] 6.6210746 8.6969330 8.4536443 2.8493697 5.4162085 2.6895456 4.9329605
 [22] 8.7546774 4.4669385 1.7959359 6.9110162 9.9022721 1.4225464 0.4807879
 [29] 5.4191476 0.8891506 1.2636342 6.3981604 5.7563299 4.9629764 6.7395878
 [36] 1.4438007 1.2132791 0.5697640 1.6751086 8.7858503 5.6589569 1.9404099
 [43] 4.5092355 4.1258410 3.6445315 2.2322484 7.9694611 2.1400881 1.6543885
 [50] 4.2557810 9.7097370 2.4922207 8.8847810 2.4900889 1.4469984 5.4061557
 [57] 6.4026069 9.6573260 7.2303004 5.8809697 2.3774659 3.5852215 3.0048248
 [64] 8.2249336 2.1836396 2.1648443 5.6176974 8.8742017 6.8282564 1.5311505
 [71] 6.4644364 7.7486986 1.3602057 0.7987116 4.9796556 0.6243775 6.2657248
 [78] 4.5741487 1.5580633 6.0322462 8.8259126 7.9592787 1.6066891 6.6356399
 [85] 5.5292079 2.4378500 5.6410685 5.2830824 5.9873868 6.4263041 7.5282190
 [92] 1.2624137 9.0030550 5.2441313 8.0708044 0.3901314 0.2934028 4.6447708
 [99] 4.6740908 4.1130734 6.1565516 9.7120159 0.3800443 2.3480880 3.7140086

$u2
  [1] 3.3719967 5.8430208 7.3973483 3.4508264 6.3413584 1.6764650 1.9929093
  [8] 0.9075115 3.2910166 1.8168163 9.6074006 4.1678433 6.2669473 6.3072725
 [15] 8.9483772 5.2233785 5.4076800 9.5326283 8.6767529 8.7276622 9.0391591
 [22] 4.8252235 6.7630201 6.9121935 2.3991153 8.8453793 3.4339991 7.9358550
 [29] 6.4678149 0.4339773 5.9769792 2.3986782 6.9218773 9.1697184 5.9028198
 [36] 6.8008923 1.3709650 7.9421969 5.6021750 1.8316436 1.5037854 2.9022997
 [43] 4.3975832 1.5823218 4.7949714 6.9225064 2.4805401 4.4148583 5.9277134
 [50] 1.3367298 3.5359341 0.2394360 5.3525379 6.6313774 7.4505182 8.4703222
 [57] 0.8340915 7.3263207 3.0809785 1.3076705 9.4520519 4.7236591 6.0641085
 [64] 4.2846131 7.6322682 6.7365555 3.6966236 1.9466746 9.0395440 7.5970721
 [71] 7.5303493 0.7316837 5.2761719 9.4079517 4.5503406 9.4233743 6.6401786
 [78] 6.0662811 0.3200192 3.1637982 9.0293274 5.9454883 3.7868699 6.5964353
 [85] 7.7817433 3.3042625 1.8327345 9.5893222 2.5490251 4.6668310 5.1016270
 [92] 8.8136535 2.9990055 0.9113731 4.5666011 1.6030848 5.9183764 5.7618805
 [99] 9.7011809 7.7685068 8.8802319 2.7783633 3.0018440 1.6846641 6.9620891

$N
        
         (0,1] (1,2] (2,3] (3,4] (4,5] (5,6] (6,7] (7,8] (8,9] (9,10]
  (0,1]      1     2     0     1     0     1     0     2     0      3
  (1,2]      1     1     1     2     0     4     2     2     1      0
  (2,3]      2     1     0     1     1     1     4     1     1      2
  (3,4]      0     0     0     0     2     0     2     0     0      0
  (4,5]      0     2     0     0     2     1     2     1     0      3
  (5,6]      1     3     1     2     0     0     3     2     2      1
  (6,7]      1     1     2     1     1     1     2     1     2      1
  (7,8]      1     0     1     1     1     2     1     0     0      0
  (8,9]      0     2     0     2     3     3     0     0     0      1
  (9,10]     0     1     2     1     0     0     0     1     1      0

$z
        
         (0,1] (1,2] (2,3] (3,4] (4,5] (5,6] (6,7] (7,8] (8,9] (9,10]
  (0,1]      1     1     0     1     0     1     0     1     0      1
  (1,2]      1     1     1     1     0     1     1     1     1      0
  (2,3]      1     1     0     1     1     1     1     1     1      1
  (3,4]      0     0     0     0     1     0     1     0     0      0
  (4,5]      0     1     0     0     1     1     1     1     0      1
  (5,6]      1     1     1     1     0     0     1     1     1      1
  (6,7]      1     1     1     1     1     1     1     1     1      1
  (7,8]      1     0     1     1     1     1     1     0     0      0
  (8,9]      0     1     0     1     1     1     0     0     0      1
  (9,10]     0     1     1     1     0     0     0     1     1      0

$psi
[1] 0.65</code></pre>
</div>
</div>
<p>La función simula ubicaciones de animales o plantas en una cuadrícula de celdas que forma un cuadrante con un tamaño total (unidades totales) igual a <code>quad.size</code>, según un proceso de Poisson en el que los individuos se distribuyen al azar en el espacio. Este proceso se caracteriza por una intensidad, o número esperado de plantas o animales (“puntos”) por unidad de área. El patrón de puntos resultante se discretiza superponiendo una cuadrícula con celdas cuadradas de longitud <code>cell.size</code>. Esta discretización del espacio es lo que permite definir la abundancia en primer lugar y, luego, la presencia/ausencia o ocurrencia. La riqueza de especies, la tercera cantidad crucial mencionada en el título, es la suma de especies que ocurren en un sitio, lo que representa un resumen de los patrones de puntos, no para una sola especie, sino para un conjunto de especies presentes en un sitio.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">82</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>tmp <span class="ot">&lt;-</span> <span class="fu">sim.fn</span>(<span class="at">quad.size =</span> <span class="dv">16</span>, <span class="at">cell.size =</span> <span class="dv">2</span>, <span class="at">intensity =</span> <span class="fl">0.5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>En esta simulación, un “sitio” está representado por una celda en toda la cuadrícula. Tal vez puedas imaginar la cuadrícula completa como una región en la que se lleva a cabo tu estudio. Solo una vez que hemos establecido esa discretización del espacio, podemos definir la abundancia (que nos gusta denotar como <em>N</em>) o la ocurrencia (presencia/ausencia) la cual nos gusta denotar como <em>z</em>). Luego, la abundancia <em>N</em> es simplemente el número de puntos que caen en cada “sitio” (es decir, celda): si no hay puntos en una celda, la abundancia es cero; si hay un punto, la abundancia es uno; y así sucesivamente. Además, la presencia/ausencia (<em>z</em>) distingue los dos casos en los que no hay puntos en una celda (es decir, <em>N</em> = <em>0</em>, lo cual representa una ausencia o no ocurrencia) o en los que hay uno o más puntos en la celda (es decir, <em>N</em> &gt; <em>0</em>, lo cual representa una presencia u ocurrencia). Así, podemos decir que la abundancia es un primer paso en la agregación de un patrón de puntos subyacente dentro de un esquema de discretización espacial, y la ocurrencia es un segundo paso en esta agregación sobre las unidades espaciales.</p>
<p>Alternativamente, podemos decir que la ocurrencia es un resumen simplificado y con poca información de la abundancia, donde solo se registran dos clases de abundancia: una siendo cero (=“ausencia”) y la La otra clase mayor a cero (= “presencia”). Así, las relaciones entre un patrón de puntos, abundancia y ocurrencia son determinísticas en un solo sentido: si se conoce el patrón completo y se tiene un esquema de discretización espacial, también se tiene conocimiento completo sobre la abundancia; y si se conoce el patrón espacial de abundancia, también se conoce perfectamente el patrón espacial de ocurrencia. En cambio, el proceso inverso no es tan directo; por ejemplo, al conocer solo un patrón de presencia/ausencia, no puedes inferir perfectamente la distribución subyacente de abundancia, aunque puedes hacer inferencias estadísticas explícitas (He y Gaston, 2000; Royle et al., 2003; Ramsey et al., 2015).</p>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<p>Curiosamente, sin conocer la relación entre los procesos puntuales y sus abundancias y ocurrencias interrelacionadas, a las personas siempre les ha gustado discretizar su área de estudio completa en subunidades más pequeñas, o, dicho de otra manera, replicar sus áreas de estudio en el espacio. Esto da lugar a lo que llamamos un “diseño de meta-población” (Royle, 2004a; Kéry y Royle, 2010). “Somos un tanto cautelosos con este término porque no queremos implicar que los animales que viven en tales unidades espaciales discretas necesariamente se comportan según una metapoblación formal (Hanski, 1998; Sutherland et al., 2012, 2014). Más bien, no pudimos encontrar un término mejor y más conciso para el caso extremadamente común en el que se estudia la distribución o abundancia en una colección de sitios espacialmente replicados o donde toda un área de estudio se subdivide en subunidades más pequeñas, a las que típicamente llamamos sitios” (kery and Royle, 2016). Para Kery and Royle, esto es un “diseño de meta-población”.</p>
<p>Tales diseños de meta-población, o diseños con poblaciones espacialmente subdivididas, son extremadamente comunes en ecología y todas las ciencias relacionadas. Además, se adoptan prácticamente en todas partes en el monitoreo biológico, donde está claro que no se puede caracterizar el estado del medio ambiente solo con mediciones tomadas en un único sitio. Los diseños de meta-población vienen en una gran variedad, y el número, tamaño y forma de las celdas (subunidades) pueden variar, uno de ellos es el submuestreo espacial es sorprendentemente común en los diseños de meta-población, en los cuales cada sitio (unidad) se subdivide aún más en subunidades espaciales más pequeñas, que nuevamente pueden cubrir todo el sitio o solo una parte del área total de un sitio.</p>
</div>
<div id="tabset-1-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-3-tab">
<p>La abundancia, distribución y riqueza de especies son, quizás, las variables más estudiadas en toda la ecología y campos relacionados. Sin embargo, con mucha frecuencia hay un interés no solo en estas variables de estado, sino también en los parámetros que gobiernan la tasa de cambio de estas cantidades, es decir, que impulsan la dinámica de las poblaciones (variables de tasa). Por ejemplo, la cantidad más importante en el monitoreo de biodiversidad parece ser la “tendencia”, es decir, una tasa sostenida de cambio a lo largo del tiempo de alguna cantidad como la abundancia u ocurrencia. Y una tendencia es solo la descripción más simple de la dinámica de la población; la descripción más detallada de la dinámica de una población animal se logra mediante las cuatro tasas vitales: tasa de natalidad, tasa de inmigración, tasa de mortalidad y tasa de emigración, y estas pueden ser estratificadas por edad, sexo o posiblemente otras clases en una población de estudio.</p>
<p>Una tasa vital que ha recibido un interés particular en la ecología animal y otros campos, como la evolución de la historia de vida (Stearns, 1992), es la probabilidad de supervivencia. Existen teorías bien desarrolladas para estimar la supervivencia a partir de muestras temporales replicadas de animales salvajes marcados, por ejemplo, en el célebre modelo de Cormack-Jolly-Seber (Cormack, 1964; Jolly, 1965; Seber, 1965; Pollock et al., 1990), en su variante para datos de recuperación de anillos (Brownie et al., 1985) y en una multitud de generalizaciones, incluidos los modelos multiestados (Arnason, 1972; Hestbeck et al., 1991; Brownie et al., 1993; Arnason y Schwarz, 1999) y modelos relacionados (Barker, 1997; Pradel et al., 1997; Kendall et al., 2003; Pradel, 2005; Bonner y Schwarz, 2006).</p>
<p>En ecología animal existe una división bastante marcada entre los modelos y métodos (y curiosamente también entre las personas que aplican estos modelos) que se centran en las variables de estado (por ejemplo, estimar abundancia) o que se enfocan en las variables de tasa (por ejemplo, estimar supervivencia). Esta división es en su mayoría artificial y en gran parte se debe a las limitaciones de los modelos pasados y actuales, así como del software asociado para ajustar estos modelos. Por lo tanto, hasta hace muy poco, existía una gran división en las estadísticas ecológicas entre los modelos para “poblaciones cerradas” (lo que esencialmente significaba estimación de abundancia) y los modelos para “poblaciones abiertas” (lo que, ante todo, significaba estimación de supervivencia). Sin embargo, hoy en día, esta distinción se difumina cada vez más y, especialmente en el contexto de los modelos jerárquicos, se puede ver cuán fácilmente podemos unir lo que hace solo 10 años podría haberse considerado una división profunda. Además, la facilidad con la que podemos ajustar “modelos híbridos abiertos/cerrados” a nuestros datos se debe en gran parte al poder de la maquinaria de ajuste de modelos bayesianos y, en la práctica, al software BUGS (Schofield et al., 2009). Esto es especialmente interesante también para la el modelado de dinámicas poblacionales, como el análisis de viabilidad poblacional (Beissinger, 2002) y la modelización poblacional relacionada (Bockland et al., 2004b, 2007; Schofield y Barker, 2008; Tavecchia et al., 2009; Newman et al., 2006, 2014), incluyendo los modelos de proyección matricial (Caswell, 2001; Link et al., 2003). Finalmente, otro tipo de modelo poblacional en el que la división entre poblaciones abiertas y cerradas se elimina por completo es el fascinante campo de la modelización integrada de poblaciones (IPMs, Baillie, 1991; Besbeas et al., 2002; Brooks et al., 2004; Schaub et al., 2007; Abadi et al., 2010a,b; Schaub y Abadi, 2011).</p>
</div>
<div id="tabset-1-4" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-4-tab">
<p>El error en una medición es la diferencia entre el valor medido y el valor verdadero de alguna cantidad. Probablemente, el tipo de error de medición más conocido en ecología sea el relacionado con la medición de cantidades continuas, como el tamaño corporal, la masa corporal o el contenido de algún contaminante en el aire o el agua. Su medición está probablemente afectada por una gran cantidad de pequeñas causas que actúan de manera aditiva, dando lugar a errores de medición que típicamente siguen una distribución normal. Una consecuencia importante de esto es que las mediciones son imparciales, es decir, en promedio están en el objetivo; los errores positivos y negativos simplemente se cancelan entre sí en el promedio de mediciones repetidas. Este tipo de error de medición parece ser el que la gente tiene en mente cuando piensa en este tema en ecología. Por ejemplo, este tipo de error de medición generalmente se maneja en el residuo de un modelo de regresión.</p>
<p>Sin embargo, las cosas son muy diferentes para los conteos de variables discretas como la abundancia, y esto incluye la variable binaria “presencia/ausencia”, es decir, cuando se trata de la agregación de datos de un proceso puntual subyacente. Para ellas, puede haber subestimaciones y sobreestimaciones, y los mecanismos que conducen a los dos tipos de errores no son los mismos, sino que pueden ser muy diferentes. Así, existe un conjunto de mecanismos que lleva a errores falsos negativos, cuando se pasa por alto a un individuo o se omite una especie en un sitio donde ocurre. Este tipo de error no puede describirse razonablemente con una distribución normal, sino que típicamente se describe mediante una distribución binomial o una distribución de Bernoulli. Dado que hay <em>N</em> individuos presentes y existe alguna probabilidad p de detectar a cada uno de ellos, el número de individuos detectados (<em>C</em>) será binomial:</p>
<p><span class="math display">\[ C \sim \text{Binomial}(N, p) \]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Modelo de error de medición falso negativo para conteos</p>
</div>
</div>
<p>Aquí, p es la probabilidad de detección o encuentro de un individuo y representa el complemento de la tasa de error falso negativo, es decir, la tasa de error asociada es 1-p.&nbsp;De manera similar, para el estado de presencia/ausencia de una especie en un sitio, z, donde z = 1 denota presencia y z = 0 denota ausencia, podemos especificar el siguiente modelo de error de medición para la medición de presencia/ausencia o para el dato de detección/no detección en un sitio ocupado:</p>
<p><span class="math display">\[ y \sim \text{Bernoulli}(p) \]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Modelo de error de medición falso negativo para observaciones de detección/no detección.</p>
</div>
</div>
<p>En cualquiera de los casos, y a diferencia del modelo normal para errores de medición con variables continuas, el promedio de mediciones repetidas no será imparcial con respecto a las cantidades objetivo (N de abundancia o presencia/ausencia). Más bien, el promedio será igual a <em>Np</em> para los conteos y igual a <em>p</em> para las mediciones de presencia/ausencia (observaciones de detección/no detección) en un sitio ocupado. En contraste, el máximo entre una serie de mediciones se acercará cada vez más a los valores verdaderos <em>N</em> o <em>z</em> a medida que se aumente el número de mediciones repetidas, y qué tan rápido se acerca el máximo a <em>N</em> depende nuevamente de la probabilidad de detección <em>p</em>.</p>
</div>
<div id="tabset-1-5" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-5-tab">
<p>El error de detección de falsos negativos, es el error de detección que se aborda en la gran mayoría de los métodos de captura-recaptura y métodos relacionados. En la base de prácticamente todos estos métodos está el modelo de error de medición binomial o de Bernoulli. Se podría argumentar que los errores de falsos negativos ocurren en casi todos los conjuntos de datos sobre distribución y abundancia, ya sea para animales o plantas.</p>
<p>Además de los errores de falsos negativos, también podemos tener errores de falsos positivos. Por ejemplo, en términos de abundancia, podríamos sobrecontar, generalmente porque contamos al mismo individuo varias veces o porque confundimos una especie con otra. En términos de ocurrencia, esto significa que creemos haber detectado una especie en un sitio donde en realidad no ocurre o que creemos haberla detectado en un sitio donde sí ocurre, pero lo que observamos no era la especie objetivo; revisar <a href="https://doi.org/10.1890/14-1507.1">Chambert et al.&nbsp;(2015)</a> para más detalles sobre esta distinción.</p>
<p>Cuando tratamos con datos resumidos en áreas discretizadas a partir de patrones de puntos “simples”, es decir, datos de abundancia u ocurrencia, estos son los dos tipos fundamentales de errores de medición. Sin embargo, además, existen errores de clasificación de estado cuando clasificamos individuos por edad, tamaño u otros estados, como en los modelos de estados múltiples y cuando distinguimos entre diferentes tipos de “ocurrencia”, como la de individuos no reproductivos frente a la de individuos reproductivos, como en los modelos de ocupación de estados múltiples.</p>
<p>Cuando trabajamos directamente con los datos del patrón de puntos subyacente, surge un tercer tipo fundamental de error: el error de localización. Es decir, una diferencia entre las coordenadas reales en las que se encuentra un individuo cuando lo detectamos y las coordenadas que registramos e introducimos en nuestro modelo. El error de localización debe abordarse en modelos espacialmente explícitos para abundancia o densidad porque, de lo contrario, se obtienen estimadores sesgados. El marco de modelado espacialmente explícito más simple para abundancia, el muestreo por distancia convencional, elimina el problema al requerir como uno de sus principales supuestos que el error de localización sea nulo. Curiosamente, una vez que “olvidamos” las ubicaciones individuales al agregar un patrón de puntos para convertirlo en datos de abundancia u ocurrencia, el error de localización “desaparece” y se traduce en errores de falsos positivos o falsos negativos. Si el error de localización hace que un individuo se registre erróneamente en una celda vecina, entonces ese registro se convierte en un falso positivo en esa celda y corresponderá a un falso negativo en la celda donde realmente se encuentra el individuo. Si el error de localización no lleva al registro del individuo en una celda diferente de aquella donde realmente está, no tiene consecuencias en el modelado de la abundancia o ocurrencia.</p>
<p>En ecología, hay otro tipo de error de medición: el que ocurre en las covariables. Este es bastante diferente de los otros tipos de errores de medición mencionados en esta sección, que están asociados con la respuesta en un modelo, no con una covariable en el modelo. El problema de los errores en covariables en modelos de distribución y abundancia es exactamente análogo al de cualquier otro modelo de regresión. Esencialmente, los errores de medición en covariables continuas atenúan la estimación de la pendiente, es decir, hacen que la estimación erróneamente se acerque a cero. Existe una cantidad considerable de literatura estadística sobre este tipo de error de medición <a href="https://www.tandfonline.com/doi/abs/10.1080/01621459.2000.10474347">(Stefanski, 2000)</a>.</p>
<p>Por lo tanto, generalmente no es suficiente que un modelo ecológico de distribución y abundancia simplemente describa la variabilidad espacial de un proceso y posiblemente también las dinámicas temporales en la abundancia u ocurrencia. Más bien, para lograr inferencias no sesgadas sobre la demografía de la distribución y la abundancia, será necesario modelar explícitamente los procesos de error de medición que subyacen a los datos disponibles. Los estudios que emplean diseños de metapoblación suelen enfrentar dos pasos inferenciales secuenciales (ver Figura 1.1). <img src="booksPictures/Figure1.png" class="img-fluid"> Figura 1.1: Los dos procesos de muestreo en ecología que típicamente subyacen a la medición de la abundancia o la ocurrencia son: primero, el muestreo espacial y, luego, la medición de la cantidad deseada. <em>N</em> y <em>z</em> denotan las cantidades típicas de interés (abundancia y presencia/ausencia, respectivamente), mientras que <em>C</em> e <em>y</em> representan sus mediciones, ya sea un conteo o una medición de detección/no detección, respectivamente.</p>
<p>El primero es desde la muestra de sitios muestreados hacia una “población” estadística más amplia de sitios en los que estamos interesados. Necesitamos un modelo estadístico para describir la variabilidad entre estos sitios y el muestreo de los sitios relevados para inferir cantidades en toda la región. Y, en segundo lugar, necesitamos otro modelo estadístico para describir la aleatoriedad en el proceso de medición, típicamente para estimar y, por lo tanto, corregir las tasas de error de falsos negativos y falsos positivos. Este procedimiento de muestreo en dos pasos es ubicuo en la ecología y especialmente en el monitoreo de biodiversidad.</p>
</div>
<div id="tabset-1-6" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-6-tab">
<p>Los modelos jerárquicos son una secuencia de modelos de probabilidad ordenados según su estructura de probabilidad condicional, lo que implica que describen variables aleatorias condicionalmente dependientes. En el contexto de los modelos descritos y analizados en este curso, utilizaremos modelos jerárquicos para representar tanto el verdadero estado de la naturaleza, que no es observable (o solo parcialmente observable), como los errores de medición.</p>
<p>Típicamente, nuestros modelos jerárquicos incluyen un submodelo para el estado verdadero de interés y otro para los errores de medición, aunque en algunos casos puede haber más de un submodelo para cualquiera de estos aspectos. En el caso más común, donde el modelo aborda únicamente errores de detección falsos negativos, el nivel “inferior” del modelo jerárquico (donde se encuentran los datos) es una distribución binomial (o Bernoulli) donde la “probabilidad de éxito” se interpreta como la probabilidad de detección. En cierto sentido, esto convierte a la mayoría de los modelos presentados en este curso en una versión sofisticada de una regresión logística, pero con estructuras de efectos aleatorios posiblemente muy complejas. Otros aspectos del patrón espacio-temporal de ocurrencia o abundancia, o de cómo observamos esos patrones, pueden ser representados mediante niveles adicionales en el modelo, especialmente agrupaciones por sitio, especie, etc.</p>
<p>Los modelos jerárquicos son una herramienta para realizar inferencias sobre distribución, abundancia, riqueza de especies y otras cantidades demográficas relacionadas en poblaciones, metapoblaciones, comunidades y metacomunidades. Son ideales para integrar, en un solo modelo, múltiples conjuntos de datos, múltiples fuentes de variabilidad (espacial, temporal y espacio-temporal) y múltiples escalas de medición. Además, permiten propagar rigurosamente la incertidumbre combinada hacia cada estimación derivada del modelo. Su implementación en un marco Bayesiano con métodos de cadenas de Markov Monte Carlo (MCMC) ofrece una potencia casi ilimitada para su aplicación a datos reales.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>La implementación en un marco Bayesiano con métodos de cadenas de Markov Monte Carlo (MCMC) solo se desarollará en la clase de supervicenvia relativa.</p>
</div>
</div>
<p>Adicionalmente, los modelos jerárquicos representan una “compartimentalización” natural de un sistema grande y complejo en una secuencia de subsistemas más pequeños y, por lo general, mucho menos complejos. (De hecho, el término “modelos secuenciales” podría ser igualmente adecuado para describirlos). Este es un marco ideal para describir conjuntamente el verdadero estado y dinámica de un sistema subyacente de interés, como una población de animales o plantas, o una metapoblación, y los procesos de medición potencialmente complejos con diversos tipos de error, posiblemente heterogéneos.</p>
</div>
</div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="HN%20Cursos%20publicidad/HN%20Biology%20Inv%20large.jpg" class="img-fluid figure-img"></p>
<figcaption>HN Biology Investigation Academy</figcaption>
</figure>
</div>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>