---
title: "Clase 8: Modelos jerárquicos de supervivencia"
author: "David Murillo"
format:
  html:
    css: styles.css
---

El tema de esta clase es el célebre modelo Cormack-Jolly-Seber, o CJS (Cormack, 1964; Jolly, 1965; Seber, 1965), uno de los modelos estadísticos más famosos en ecología. El modelo CJS requiere datos de captura-recaptura en vivo (también llamados marcaje-recaptura o marcaje-reseñamiento) de individuos reconocibles individualmente. Esto generalmente significa individuos marcados (etiquetados), pero la identificación genética y, a veces, la variabilidad natural en el color o los patrones de plumas/pelaje/piel pueden servir igualmente bien para identificar de manera única a los individuos. El modelo CJS produce estimaciones de la probabilidad aparente de supervivencia  $\phi$, la probabilidad de que un individuo marcado permanezca vivo y en el área de estudio entre dos puntos temporales en los que se realizan los reconocimientos, y de la probabilidad de recaptura *p*, la probabilidad de que un individuo marcado se encuentre en un punto temporal determinado (nótese que la identificación en el tiempo amplio se refiere al re-avistamiento y cualquier otra forma de identificación individual). Sorprendentemente, el modelo CJS también estima la probabilidad de un evento (muerte), ¡aunque nunca observamos directamente ese evento!

Las bases y el diseño para producir datos susceptibles de análisis bajo un modelo CJS es aquel en el que se define un área de estudio fija y luego se sale y se intenta capturar y marcar tantos individuos como se definan. En ocasiones fijas, el primer registro de un individuo reconocible por sus marcas naturales o genéticas, etc. es funcionalmente idéntico al primer marcado de ese individuo. Luego, en cada ocasión, se registra la identidad de los individuos que ya tienen una marca y se coloca una nueva marca en aquellos que no la tienen. Los datos básicos se resumen en la matriz de historial de captura o detección **Y** de dimensiones *n* x *T*, donde *T* es el número de ocasiones Y *n* es el número de animales marcados primero hasta la ocasión *T*-1; aquellos marcados en la ocasión *T* no proporcionan ninguna información sobre la supervivencia y pueden ignorarse. La entrada (*i*,*t*) de la matriz contiene un 1 cuando el individuo *i* fue detectado en la ocasión 1 y un 0 cuando no lo fue.

Es crucial que la extensión espacial de un área de estudio permanezca igual a lo largo del tiempo, porque en el modelo CJS estamos estimando la supervivencia aparente: el producto de la supervivencia real (*S*) y la probabilidad de permanecer en el área de estudio (es decir, fidelidad *F*). A partir de datos simples (no espaciales) de captura-recaptura, no es posible separar estos dos componentes (aunque se hace posible con modelos CJS espacialmente explícitos. Por lo tanto, si extiende su área de estudio a lo largo del tiempo, más individuos marcados tenderán a permanecer dentro de sus límites, *F* aumentará y también lo hará la supervivencia aparente. A menudo, las ocasiones de captura se espacian regularmente, por ejemplo, durante la temporada de reproducción en cada año, pero no es necesario que así sea, y hay diferentes formas de lidiar con intervalos de tiempo desiguales. Además, lo ideal es que la captura sea instantánea y no que se extienda de forma continua en el tiempo (también existen modelos de supervivencia para datos recopilados en tiempo continuo. Por último, si queremos que nuestras estimaciones caractericen a la población en general en lugar de solo a la muestra de individuos capturados, debemos apuntar a capturar una muestra aleatoria de individuos de la población (y sin extendernos en esto, solo afirmamos que esto puede ser más desafiante de lo que parece a primera vista).

## Modelos básicos de Cormack-Jolly-Seber

### El modelo básico de CJS como modelo de espacio de estados o jerárquico

Fundamentalmente, el modelo CJS puede considerarse un modelo jerárquico o de espacio de estados (SSM), porque distingue entre un estado latente binario (vivo, muerto) y un estado observado binario (detectado, no detectado). La dinámica del estado latente se describe de la manera habitual de un SSM, describiendo el estado inicial de cada individuo y utilizando una regla probabilística por la que cambia de estado desde el momento *t* a *t* +1. Sin embargo, hay dos cosas un tanto peculiares. En primer lugar, el estado latente inicial de cada individuo no se modela de forma probabilística, sino que se fija en 1. Es decir, el modelo condiciona la primera captura (cuando el individuo estaba vivo por definición) y solo describe los eventos aleatorios posteriores a la primera captura. Esto es bastante diferente en otros modelos de estado sólido relacionados para respuestas binarias, como el modelo Jolly-Seber o en el modelo de ocupación dinámica, los cuales modelan una matriz de historial de detección desde el inicio (es decir, con la columna 1) de manera probabilística. En segundo lugar, en el modelo CJS, las transiciones en el estado latente solo son posibles en una dirección, de vivo a muerto. Esto es nuevamente diferente en el modelo de ocupación dinámica relacionado, donde las colonizaciones son posibles. Por último, los modelos típicos de "supervivencia del nido" o "destino conocido" difieren del modelo CJS principalmente por la ausencia de un modelo de observación, porque su estado latente se observa perfectamente si es que se observa. Todos estos modelos son equivalentes a los modelos ocultos de Markov (HMM; Zucchini et al., 2016): modelos de series temporales jerárquicos con estados discretos solamente y donde la regla de transición se refiere a un solo paso atrás en el tiempo, es decir, el modelo es markoviano de orden 1. Sin embargo, de manera un tanto confusa, la probabilidad del modelo CJS a menudo se expresa de una manera no jerárquica, en lugar de construirse de una manera jerárquica explícita. Para esto, la matriz básica del historial de captura se agrega por cohorte de liberación y ocasión de recaptura en el llamado *formato m-array*. La probabilidad de cada celda de esta matriz agregada se puede expresar como una función de parámetros específicos del tiempo de aparente supervivencia y recaptura, y el ajuste del modelo se realiza maximizando una probabilidad multinomial producto. Esta es la probabilidad maximizada en la mayoría de los programas frecuentistas para el modelo CJS.

Con el formato m-array, la probabilidad CJS se colapsa sobre los estados latentes *z* (ver más abajo) y, por lo tanto, en un sentido técnico, el modelo ya no es jerárquico, aunque conceptualmente lo es. En cambio, en programas bayesianos como BUGS, podemos ajustar el modelo tanto utilizando la construcción jerárquica directa de la probabilidad, como utilizando la agregación de matriz m-array. Podría decirse que la primera es conceptualmente más fácil de entender y, además, permite ajustar modelos más generales, pero la segunda es computacionalmente más eficiente (y a menudo mucho más eficiente).

En el formato SSM, los datos de historial de captura observados y, son iguales a 1 si el individuo *i* es detectado (es decir, capturado) en la ocasión *t* y 0 si no es detectado. Se describen en términos de una variable latente $z_{i,t}$, que dice si ese individuo estaba vivo ($z_{i,t} = 1$) o muerto ($z_{i,t} = 0$) en la ocasión *t*, y dos parámetros, las probabilidades de supervivencia aparente $\phi$ y de recaptura $p$, que, para mayor claridad, aquí asumimos primero que son constantes. Dado que el modelo CJS se define condicional a la primera captura y se conoce el estado verdadero en la primera captura, también necesitamos un vector que contenga la ocasión de marcado, llamado $f$, para describir los datos observados de manera probabilística, es decir, para formar su probabilidad. Luego, describimos la parte latente del sistema en dos líneas:

$z_{i,f = 1}$ (para la ocasión de marcado)

$z_{i,t+1}|z_{i,t} \sim Bernoulli(z_{i,1}\phi)$ (para todas las ocasiones posteriores)

Por lo tanto, después de la ocasión de marcado, el estado vivo/muerto es un simple ensayo de Bernoulli condicional con probabilidad de éxito $z_i\phi$; la multiplicación con $z_i$, asegura que el individuo $i$ permanezca muerto una vez que haya muerto. Este es el submodelo de proceso del modelo jerárquico. Para describir el proceso de observación, asumimos que no hay falsos positivos (por ejemplo, ninguna marca se identifica erróneamente) y adoptamos otra distribución de Bernoulli (condicional).

$y_{i,t}|z_{i,t}\sim Bernoulli(z_{i,t}p)$ El (sub)modelo de observación

Por lo tanto, que un individuo sea detectado o no depende de dos cosas: si está vivo y de la probabilidad de recaptura $p$. En el caso más general, podemos permitir que ambos parámetros del modelo difieran según el individuo $i$ y el tiempo $t$ y, a continuación, se puede especificar una gran cantidad de patrones para ellos agregando efectos de covariables o efectos aleatorios. Un conjunto de presencia o ausencia de efectos temporales conduce a la clasificación clásica de modelos $\phi(t)p(t)$, $\phi(t)p(.)$, $\phi(.)p(t)$, $\phi(.)p(.)$ clasificación de modelos con parámetros que son constantes (.) o totalmente dependientes del tiempo ($t$) (Cooch y White, 2019).

Referencia, Capítulo 3: [Aplied Hierarchical Modeling in Ecology, Volumen 2](https://www.sciencedirect.com/book/9780128237687/applied-hierarchical-modeling-in-ecology-analysis-of-distribution-abundance-and-species-richness-in-r-and-bugs)

::: panel-tabset

## Datos sobre el GWWA

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(jagsUI)
library(AHMbook)

```


```{r}
data(willowWarbler)
str(willowWarbler)

willowWarbler$birds$cesID <- as.character(willowWarbler$birds$cesID)
willowWarbler$CES$cesID <- as.character(willowWarbler$CES$cesID)

```

```{r}
attach (willowWarbler)
ch <- as.matrix(birds[, 1:11])
sitevec <- birds$cesID
```


```{r}
(nyear <- ncol(ch))        # Number years: 11
(nsite <- nrow(CES))       # Number of CE sites: 193
(nblock <- nrow(blocks))   # Number of blocks: 495

```

```{r}
(marr <- ch2marray(ch))
```

```{r}
# Calculate the number of birds released each year 1–10
(r <- apply(marr, 1, sum))
```

```{r}
# Create 3d (or multi-site) m-array and r array: MARR and R
MARR <- array(NA, dim = c(10, nyear, nsite))
R <- array(NA, dim = c(10, nsite))

for(k in 1:nsite){
  sel.part <- ch[sitevec == k, ]
  ma <- ch2marray(sel.part)
  MARR[,,k] <- ma
  R[,k] <- apply(ma, 1, sum)
}



```


```{r}
# Bundle and summarize data set
str(bdata <- list(MARR = MARR, R = R, n.site = nsite, n.occ = nyear))
```
## Modelo 1

```{r}
# Specify model in BUGS language
cat(file = "cjs6.txt","
model {

  # Priors and linear models
  for (s in 1:n.site){
    for (t in 1:(n.occ-1)){
      phi[t, s] <- ilogit(lphi[t, s]) # survival
      p[t, s] <- ilogit(lp[t, s]) # recapture
      lphi[t, s] <- alpha.lphi.site[s] + beta.lphi.time[t]
      lp[t, s] <- alpha.lp.site[s] + beta.lp.time[t]
    }
    # Define random site effects
    alpha.lphi.site[s] ~ dnorm(mu.lphi, tau.lphi.site)
    alpha.lp.site[s] ~ dnorm(mu.lp, tau.lp.site)
    mean.phi.site[s] <- ilogit(alpha.lphi.site[s])
    mean.p.site[s] <- ilogit(alpha.lp.site[s])
  }
  # Define random year effects
  for (t in 1:(n.occ-1)){
    beta.lphi.time[t] ~ dnorm(0, tau.lphi.time)
    beta.lp.time[t] ~ dnorm(0, tau.lp.time)
    mean.phi.time[t] <- ilogit(mu.lphi + beta.lphi.time[t])
    mean.p.time[t] <- ilogit(mu.lp + beta.lp.time[t])
  }

  # Hyperpriors for hyperparams
  mu.lphi <- logit(mean.phi)
  mean.phi ~ dunif(0, 1)
  mu.lp <- logit(mean.p)
  mean.p ~ dunif(0, 1)
  tau.lphi.site <- pow(sd.lphi.site, -2)
  sd.lphi.site ~ dunif(0, 3)
  tau.lp.site <- pow(sd.lp.site, -2)
  sd.lp.site ~ dunif(0, 3)
  tau.lphi.time <- pow(sd.lphi.time, -2)
  sd.lphi.time ~ dunif(0, 3)
  tau.lp.time <- pow(sd.lp.time, -2)
  sd.lp.time ~ dunif(0, 3)

  # Multinomial likelihood for the m-array data (JAGS style)
  for (s in 1:n.site){
    for (t in 1:(n.occ-1)){
      MARR[t,1:n.occ,s] ~ dmulti(pr[t, , s], R[t,s])
    }
  }
  # Define the cell probabilities of the m-array
  # Main diagonal
  for (s in 1:n.site){
    for (t in 1:(n.occ-1)){
      q[t,s] <- 1-p[t,s] # Probability of non-recapture
      pr[t,t,s] <- phi[t,s]*p[t,s]
      # Above main diagonal
      for (j in (t+1):(n.occ-1)){
        pr[t,j,s] <- prod(phi[t:j,s])*prod(q[t:(j-1),s])*p[j,s]
      } #j
      # Below main diagonal
      for (j in 1:(t-1)){
        pr[t,j,s] <- 0
      }
    }
  }
  # Last column: probability of non-recapture
  for (s in 1:n.site){
    for (t in 1:(n.occ-1)){
      pr[t,n.occ,s] <- 1-sum(pr[t,1:(n.occ-1),s])
    }
  }
}
")

```


```{r}
# Initial values
inits <- function(){list(mean.phi = runif(1), mean.p = runif(1))}

# Parameters monitored
params <- c("mean.phi", "mean.p", "sd.lphi.site", "sd.lp.site",
    "sd.lphi.time", "sd.lp.time", "mean.phi.site", "mean.p.site",
    "mean.phi.time", "mean.p.time")
```


```{r}
# MCMC settings
# na <- 1000 ; ni <- 30000 ; nt <- 10 ; nb <- 20000 ; nc <- 3
na <- 100 ; ni <- 300 ; nt <- 1 ; nb <- 200 ; nc <- 3  # ~~~ for testing

# Call JAGS (ART 192 min), check convergence and summarize posteriors
out6 <- jags(bdata, inits, params, "cjs6.txt", n.adapt = na, n.chains = nc,
    n.thin = nt, n.iter = ni, n.burnin = nb)
```





:::

