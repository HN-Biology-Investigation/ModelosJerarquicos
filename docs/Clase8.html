<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="David Murillo">

<title>Clase 8: Modelos jerárquicos de supervivencia</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Clase8_files/libs/clipboard/clipboard.min.js"></script>
<script src="Clase8_files/libs/quarto-html/quarto.js"></script>
<script src="Clase8_files/libs/quarto-html/popper.min.js"></script>
<script src="Clase8_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Clase8_files/libs/quarto-html/anchor.min.js"></script>
<link href="Clase8_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Clase8_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Clase8_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Clase8_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Clase8_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Clase 8: Modelos jerárquicos de supervivencia</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>David Murillo </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>El tema de esta clase es el célebre modelo Cormack-Jolly-Seber, o CJS (Cormack, 1964; Jolly, 1965; Seber, 1965), uno de los modelos estadísticos más famosos en ecología. El modelo CJS requiere datos de captura-recaptura en vivo (también llamados marcaje-recaptura o marcaje-reseñamiento) de individuos reconocibles individualmente. Esto generalmente significa individuos marcados (etiquetados), pero la identificación genética y, a veces, la variabilidad natural en el color o los patrones de plumas/pelaje/piel pueden servir igualmente bien para identificar de manera única a los individuos. El modelo CJS produce estimaciones de la probabilidad aparente de supervivencia <span class="math inline">\(\phi\)</span>, la probabilidad de que un individuo marcado permanezca vivo y en el área de estudio entre dos puntos temporales en los que se realizan los reconocimientos, y de la probabilidad de recaptura <em>p</em>, la probabilidad de que un individuo marcado se encuentre en un punto temporal determinado (nótese que la identificación en el tiempo amplio se refiere al re-avistamiento y cualquier otra forma de identificación individual). Sorprendentemente, el modelo CJS también estima la probabilidad de un evento (muerte), ¡aunque nunca observamos directamente ese evento!</p>
<p>Las bases y el diseño para producir datos susceptibles de análisis bajo un modelo CJS es aquel en el que se define un área de estudio fija y luego se sale y se intenta capturar y marcar tantos individuos como se definan. En ocasiones fijas, el primer registro de un individuo reconocible por sus marcas naturales o genéticas, etc. es funcionalmente idéntico al primer marcado de ese individuo. Luego, en cada ocasión, se registra la identidad de los individuos que ya tienen una marca y se coloca una nueva marca en aquellos que no la tienen. Los datos básicos se resumen en la matriz de historial de captura o detección <strong>Y</strong> de dimensiones <em>n</em> x <em>T</em>, donde <em>T</em> es el número de ocasiones Y <em>n</em> es el número de animales marcados primero hasta la ocasión <em>T</em>-1; aquellos marcados en la ocasión <em>T</em> no proporcionan ninguna información sobre la supervivencia y pueden ignorarse. La entrada (<em>i</em>,<em>t</em>) de la matriz contiene un 1 cuando el individuo <em>i</em> fue detectado en la ocasión 1 y un 0 cuando no lo fue.</p>
<p>Es crucial que la extensión espacial de un área de estudio permanezca igual a lo largo del tiempo, porque en el modelo CJS estamos estimando la supervivencia aparente: el producto de la supervivencia real (<em>S</em>) y la probabilidad de permanecer en el área de estudio (es decir, fidelidad <em>F</em>). A partir de datos simples (no espaciales) de captura-recaptura, no es posible separar estos dos componentes (aunque se hace posible con modelos CJS espacialmente explícitos. Por lo tanto, si extiende su área de estudio a lo largo del tiempo, más individuos marcados tenderán a permanecer dentro de sus límites, <em>F</em> aumentará y también lo hará la supervivencia aparente. A menudo, las ocasiones de captura se espacian regularmente, por ejemplo, durante la temporada de reproducción en cada año, pero no es necesario que así sea, y hay diferentes formas de lidiar con intervalos de tiempo desiguales. Además, lo ideal es que la captura sea instantánea y no que se extienda de forma continua en el tiempo (también existen modelos de supervivencia para datos recopilados en tiempo continuo. Por último, si queremos que nuestras estimaciones caractericen a la población en general en lugar de solo a la muestra de individuos capturados, debemos apuntar a capturar una muestra aleatoria de individuos de la población (y sin extendernos en esto, solo afirmamos que esto puede ser más desafiante de lo que parece a primera vista).</p>
<section id="modelos-básicos-de-cormack-jolly-seber" class="level2">
<h2 class="anchored" data-anchor-id="modelos-básicos-de-cormack-jolly-seber">Modelos básicos de Cormack-Jolly-Seber</h2>
<section id="el-modelo-básico-de-cjs-como-modelo-de-espacio-de-estados-o-jerárquico" class="level3">
<h3 class="anchored" data-anchor-id="el-modelo-básico-de-cjs-como-modelo-de-espacio-de-estados-o-jerárquico">El modelo básico de CJS como modelo de espacio de estados o jerárquico</h3>
<p>Fundamentalmente, el modelo CJS puede considerarse un modelo jerárquico o de espacio de estados (SSM), porque distingue entre un estado latente binario (vivo, muerto) y un estado observado binario (detectado, no detectado). La dinámica del estado latente se describe de la manera habitual de un SSM, describiendo el estado inicial de cada individuo y utilizando una regla probabilística por la que cambia de estado desde el momento <em>t</em> a <em>t</em> +1. Sin embargo, hay dos cosas un tanto peculiares. En primer lugar, el estado latente inicial de cada individuo no se modela de forma probabilística, sino que se fija en 1. Es decir, el modelo condiciona la primera captura (cuando el individuo estaba vivo por definición) y solo describe los eventos aleatorios posteriores a la primera captura. Esto es bastante diferente en otros modelos de estado sólido relacionados para respuestas binarias, como el modelo Jolly-Seber o en el modelo de ocupación dinámica, los cuales modelan una matriz de historial de detección desde el inicio (es decir, con la columna 1) de manera probabilística. En segundo lugar, en el modelo CJS, las transiciones en el estado latente solo son posibles en una dirección, de vivo a muerto. Esto es nuevamente diferente en el modelo de ocupación dinámica relacionado, donde las colonizaciones son posibles. Por último, los modelos típicos de “supervivencia del nido” o “destino conocido” difieren del modelo CJS principalmente por la ausencia de un modelo de observación, porque su estado latente se observa perfectamente si es que se observa. Todos estos modelos son equivalentes a los modelos ocultos de Markov (HMM; Zucchini et al., 2016): modelos de series temporales jerárquicos con estados discretos solamente y donde la regla de transición se refiere a un solo paso atrás en el tiempo, es decir, el modelo es markoviano de orden 1. Sin embargo, de manera un tanto confusa, la probabilidad del modelo CJS a menudo se expresa de una manera no jerárquica, en lugar de construirse de una manera jerárquica explícita. Para esto, la matriz básica del historial de captura se agrega por cohorte de liberación y ocasión de recaptura en el llamado <em>formato m-array</em>. La probabilidad de cada celda de esta matriz agregada se puede expresar como una función de parámetros específicos del tiempo de aparente supervivencia y recaptura, y el ajuste del modelo se realiza maximizando una probabilidad multinomial producto. Esta es la probabilidad maximizada en la mayoría de los programas frecuentistas para el modelo CJS.</p>
<p>Con el formato m-array, la probabilidad CJS se colapsa sobre los estados latentes <em>z</em> (ver más abajo) y, por lo tanto, en un sentido técnico, el modelo ya no es jerárquico, aunque conceptualmente lo es. En cambio, en programas bayesianos como BUGS, podemos ajustar el modelo tanto utilizando la construcción jerárquica directa de la probabilidad, como utilizando la agregación de matriz m-array. Podría decirse que la primera es conceptualmente más fácil de entender y, además, permite ajustar modelos más generales, pero la segunda es computacionalmente más eficiente (y a menudo mucho más eficiente).</p>
<p>En el formato SSM, los datos de historial de captura observados y, son iguales a 1 si el individuo <em>i</em> es detectado (es decir, capturado) en la ocasión <em>t</em> y 0 si no es detectado. Se describen en términos de una variable latente <span class="math inline">\(z_{i,t}\)</span>, que dice si ese individuo estaba vivo (<span class="math inline">\(z_{i,t} = 1\)</span>) o muerto (<span class="math inline">\(z_{i,t} = 0\)</span>) en la ocasión <em>t</em>, y dos parámetros, las probabilidades de supervivencia aparente <span class="math inline">\(\phi\)</span> y de recaptura <span class="math inline">\(p\)</span>, que, para mayor claridad, aquí asumimos primero que son constantes. Dado que el modelo CJS se define condicional a la primera captura y se conoce el estado verdadero en la primera captura, también necesitamos un vector que contenga la ocasión de marcado, llamado <span class="math inline">\(f\)</span>, para describir los datos observados de manera probabilística, es decir, para formar su probabilidad. Luego, describimos la parte latente del sistema en dos líneas:</p>
<p><span class="math inline">\(z_{i,f = 1}\)</span> (para la ocasión de marcado)</p>
<p><span class="math inline">\(z_{i,t+1}|z_{i,t} \sim Bernoulli(z_{i,1}\phi)\)</span> (para todas las ocasiones posteriores)</p>
<p>Por lo tanto, después de la ocasión de marcado, el estado vivo/muerto es un simple ensayo de Bernoulli condicional con probabilidad de éxito <span class="math inline">\(z_i\phi\)</span>; la multiplicación con <span class="math inline">\(z_i\)</span>, asegura que el individuo <span class="math inline">\(i\)</span> permanezca muerto una vez que haya muerto. Este es el submodelo de proceso del modelo jerárquico. Para describir el proceso de observación, asumimos que no hay falsos positivos (por ejemplo, ninguna marca se identifica erróneamente) y adoptamos otra distribución de Bernoulli (condicional).</p>
<p><span class="math inline">\(y_{i,t}|z_{i,t}\sim Bernoulli(z_{i,t}p)\)</span> El (sub)modelo de observación</p>
<p>Por lo tanto, que un individuo sea detectado o no depende de dos cosas: si está vivo y de la probabilidad de recaptura <span class="math inline">\(p\)</span>. En el caso más general, podemos permitir que ambos parámetros del modelo difieran según el individuo <span class="math inline">\(i\)</span> y el tiempo <span class="math inline">\(t\)</span> y, a continuación, se puede especificar una gran cantidad de patrones para ellos agregando efectos de covariables o efectos aleatorios. Un conjunto de presencia o ausencia de efectos temporales conduce a la clasificación clásica de modelos <span class="math inline">\(\phi(t)p(t)\)</span>, <span class="math inline">\(\phi(t)p(.)\)</span>, <span class="math inline">\(\phi(.)p(t)\)</span>, <span class="math inline">\(\phi(.)p(.)\)</span> clasificación de modelos con parámetros que son constantes (.) o totalmente dependientes del tiempo (<span class="math inline">\(t\)</span>) (Cooch y White, 2019).</p>
<p>Referencia, Capítulo 3: <a href="https://www.sciencedirect.com/book/9780128237687/applied-hierarchical-modeling-in-ecology-analysis-of-distribution-abundance-and-species-richness-in-r-and-bugs">Aplied Hierarchical Modeling in Ecology, Volumen 2</a></p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true" href="">Datos sobre el GWWA</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false" href="">Modelo 1</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(jagsUI)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(AHMbook)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(willowWarbler)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(willowWarbler)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>List of 4
 $ birds :'data.frame': 10551 obs. of  12 variables:
  ..$ 1986 : num [1:10551] 1 1 1 1 1 1 1 1 1 1 ...
  ..$ 1987 : num [1:10551] 0 0 0 1 0 0 0 0 0 0 ...
  ..$ 1988 : num [1:10551] 0 0 0 0 0 0 0 0 0 0 ...
  ..$ 1989 : num [1:10551] 0 0 0 0 0 0 0 0 0 0 ...
  ..$ 1990 : num [1:10551] 0 0 0 0 0 0 0 0 0 0 ...
  ..$ 1991 : num [1:10551] 0 0 0 0 0 0 0 0 0 0 ...
  ..$ 1992 : num [1:10551] 0 0 0 0 0 0 0 0 0 0 ...
  ..$ 1993 : num [1:10551] 0 0 0 0 0 0 0 0 0 0 ...
  ..$ 1994 : num [1:10551] 0 0 0 0 0 0 0 0 0 0 ...
  ..$ 1995 : num [1:10551] 0 0 0 0 0 0 0 0 0 0 ...
  ..$ 1996 : num [1:10551] 0 0 0 0 0 0 0 0 0 0 ...
  ..$ cesID: num [1:10551] 1 1 1 1 1 1 1 1 1 1 ...
 $ cells :'data.frame': 9667 obs. of  4 variables:
  ..$ lon    : num [1:9667] 167500 172500 167500 172500 177500 ...
  ..$ lat    : num [1:9667] 12500 12500 17500 17500 17500 22500 22500 22500 22500 22500 ...
  ..$ gdd    : num [1:9667] 2136 2120 1945 1943 1956 ...
  ..$ blockID: num [1:9667] 1 1 3 3 3 2 2 3 3 3 ...
 $ CES   :'data.frame': 193 obs. of  4 variables:
  ..$ cesx   : num [1:193] 307500 432500 457500 312500 477500 ...
  ..$ cesy   : num [1:193] 92500 167500 352500 227500 377500 ...
  ..$ BlockID: num [1:193] 25 77 204 110 222 283 119 234 295 152 ...
  ..$ CellID : num [1:193] 319 1366 4302 2266 4627 ...
 $ blocks:'data.frame': 495 obs. of  2 variables:
  ..$ blockX: num [1:495] 175 150 175 200 150 175 200 225 250 275 ...
  ..$ blockY: num [1:495] 0 25 25 25 50 50 50 50 50 50 ...</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">attach</span> (willowWarbler)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>ch <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(birds[, <span class="dv">1</span><span class="sc">:</span><span class="dv">11</span>])</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>sitevec <span class="ot">&lt;-</span> birds<span class="sc">$</span>cesID</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>(nyear <span class="ot">&lt;-</span> <span class="fu">ncol</span>(ch))        <span class="co"># Number years: 11</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 11</code></pre>
</div>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>(nsite <span class="ot">&lt;-</span> <span class="fu">nrow</span>(CES))       <span class="co"># Number of CE sites: 193</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 193</code></pre>
</div>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(nblock <span class="ot">&lt;-</span> <span class="fu">nrow</span>(blocks))   <span class="co"># Number of blocks: 495</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 495</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(marr <span class="ot">&lt;-</span> <span class="fu">ch2marray</span>(ch))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]
 [1,]   55   13    1    1    0    0    0    0    0     0   622
 [2,]    0  123   17    2    1    0    0    0    0     0   652
 [3,]    0    0  143   20    4    0    0    0    0     0   855
 [4,]    0    0    0  179   16    6    0    0    0     0  1222
 [5,]    0    0    0    0  183   14    1    0    0     0  1174
 [6,]    0    0    0    0    0  161   16    5    0     0  1049
 [7,]    0    0    0    0    0    0  172   20    4     0  1087
 [8,]    0    0    0    0    0    0    0  239   41     9  1042
 [9,]    0    0    0    0    0    0    0    0  252    24  1299
[10,]    0    0    0    0    0    0    0    0    0   247  1269</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate the number of birds released each year 1–10</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>(r <span class="ot">&lt;-</span> <span class="fu">apply</span>(marr, <span class="dv">1</span>, sum))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1]  692  795 1022 1423 1372 1231 1283 1331 1575 1516</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create 3d (or multi-site) m-array and r array: MARR and R</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>MARR <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="at">dim =</span> <span class="fu">c</span>(<span class="dv">10</span>, nyear, nsite))</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>R <span class="ot">&lt;-</span> <span class="fu">array</span>(<span class="cn">NA</span>, <span class="at">dim =</span> <span class="fu">c</span>(<span class="dv">10</span>, nsite))</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(k <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nsite){</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  sel.part <span class="ot">&lt;-</span> ch[sitevec <span class="sc">==</span> k, ]</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  ma <span class="ot">&lt;-</span> <span class="fu">ch2marray</span>(sel.part)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  MARR[,,k] <span class="ot">&lt;-</span> ma</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  R[,k] <span class="ot">&lt;-</span> <span class="fu">apply</span>(ma, <span class="dv">1</span>, sum)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Bundle and summarize data set</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(bdata <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">MARR =</span> MARR, <span class="at">R =</span> R, <span class="at">n.site =</span> nsite, <span class="at">n.occ =</span> nyear))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>List of 4
 $ MARR  : num [1:10, 1:11, 1:193] 1 0 0 0 0 0 0 0 0 0 ...
 $ R     : num [1:10, 1:193] 13 5 0 0 0 0 0 0 0 0 ...
 $ n.site: int 193
 $ n.occ : int 11</code></pre>
</div>
</div>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Specify model in BUGS language</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="at">file =</span> <span class="st">"cjs6.txt"</span>,<span class="st">"</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="st">model {</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="st">  # Priors and linear models</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="st">  for (s in 1:n.site){</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="st">    for (t in 1:(n.occ-1)){</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="st">      phi[t, s] &lt;- ilogit(lphi[t, s]) # survival</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="st">      p[t, s] &lt;- ilogit(lp[t, s]) # recapture</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="st">      lphi[t, s] &lt;- alpha.lphi.site[s] + beta.lphi.time[t]</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="st">      lp[t, s] &lt;- alpha.lp.site[s] + beta.lp.time[t]</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="st">    }</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="st">    # Define random site effects</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="st">    alpha.lphi.site[s] ~ dnorm(mu.lphi, tau.lphi.site)</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="st">    alpha.lp.site[s] ~ dnorm(mu.lp, tau.lp.site)</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a><span class="st">    mean.phi.site[s] &lt;- ilogit(alpha.lphi.site[s])</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a><span class="st">    mean.p.site[s] &lt;- ilogit(alpha.lp.site[s])</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a><span class="st">  }</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span class="st">  # Define random year effects</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a><span class="st">  for (t in 1:(n.occ-1)){</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span class="st">    beta.lphi.time[t] ~ dnorm(0, tau.lphi.time)</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a><span class="st">    beta.lp.time[t] ~ dnorm(0, tau.lp.time)</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="st">    mean.phi.time[t] &lt;- ilogit(mu.lphi + beta.lphi.time[t])</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a><span class="st">    mean.p.time[t] &lt;- ilogit(mu.lp + beta.lp.time[t])</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a><span class="st">  }</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a><span class="st">  # Hyperpriors for hyperparams</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a><span class="st">  mu.lphi &lt;- logit(mean.phi)</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a><span class="st">  mean.phi ~ dunif(0, 1)</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a><span class="st">  mu.lp &lt;- logit(mean.p)</span></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a><span class="st">  mean.p ~ dunif(0, 1)</span></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a><span class="st">  tau.lphi.site &lt;- pow(sd.lphi.site, -2)</span></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a><span class="st">  sd.lphi.site ~ dunif(0, 3)</span></span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a><span class="st">  tau.lp.site &lt;- pow(sd.lp.site, -2)</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a><span class="st">  sd.lp.site ~ dunif(0, 3)</span></span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a><span class="st">  tau.lphi.time &lt;- pow(sd.lphi.time, -2)</span></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a><span class="st">  sd.lphi.time ~ dunif(0, 3)</span></span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a><span class="st">  tau.lp.time &lt;- pow(sd.lp.time, -2)</span></span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a><span class="st">  sd.lp.time ~ dunif(0, 3)</span></span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a><span class="st">  # Multinomial likelihood for the m-array data (JAGS style)</span></span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a><span class="st">  for (s in 1:n.site){</span></span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a><span class="st">    for (t in 1:(n.occ-1)){</span></span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a><span class="st">      MARR[t,1:n.occ,s] ~ dmulti(pr[t, , s], R[t,s])</span></span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a><span class="st">    }</span></span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a><span class="st">  }</span></span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a><span class="st">  # Define the cell probabilities of the m-array</span></span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a><span class="st">  # Main diagonal</span></span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a><span class="st">  for (s in 1:n.site){</span></span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a><span class="st">    for (t in 1:(n.occ-1)){</span></span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a><span class="st">      q[t,s] &lt;- 1-p[t,s] # Probability of non-recapture</span></span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a><span class="st">      pr[t,t,s] &lt;- phi[t,s]*p[t,s]</span></span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a><span class="st">      # Above main diagonal</span></span>
<span id="cb18-54"><a href="#cb18-54" aria-hidden="true" tabindex="-1"></a><span class="st">      for (j in (t+1):(n.occ-1)){</span></span>
<span id="cb18-55"><a href="#cb18-55" aria-hidden="true" tabindex="-1"></a><span class="st">        pr[t,j,s] &lt;- prod(phi[t:j,s])*prod(q[t:(j-1),s])*p[j,s]</span></span>
<span id="cb18-56"><a href="#cb18-56" aria-hidden="true" tabindex="-1"></a><span class="st">      } #j</span></span>
<span id="cb18-57"><a href="#cb18-57" aria-hidden="true" tabindex="-1"></a><span class="st">      # Below main diagonal</span></span>
<span id="cb18-58"><a href="#cb18-58" aria-hidden="true" tabindex="-1"></a><span class="st">      for (j in 1:(t-1)){</span></span>
<span id="cb18-59"><a href="#cb18-59" aria-hidden="true" tabindex="-1"></a><span class="st">        pr[t,j,s] &lt;- 0</span></span>
<span id="cb18-60"><a href="#cb18-60" aria-hidden="true" tabindex="-1"></a><span class="st">      }</span></span>
<span id="cb18-61"><a href="#cb18-61" aria-hidden="true" tabindex="-1"></a><span class="st">    }</span></span>
<span id="cb18-62"><a href="#cb18-62" aria-hidden="true" tabindex="-1"></a><span class="st">  }</span></span>
<span id="cb18-63"><a href="#cb18-63" aria-hidden="true" tabindex="-1"></a><span class="st">  # Last column: probability of non-recapture</span></span>
<span id="cb18-64"><a href="#cb18-64" aria-hidden="true" tabindex="-1"></a><span class="st">  for (s in 1:n.site){</span></span>
<span id="cb18-65"><a href="#cb18-65" aria-hidden="true" tabindex="-1"></a><span class="st">    for (t in 1:(n.occ-1)){</span></span>
<span id="cb18-66"><a href="#cb18-66" aria-hidden="true" tabindex="-1"></a><span class="st">      pr[t,n.occ,s] &lt;- 1-sum(pr[t,1:(n.occ-1),s])</span></span>
<span id="cb18-67"><a href="#cb18-67" aria-hidden="true" tabindex="-1"></a><span class="st">    }</span></span>
<span id="cb18-68"><a href="#cb18-68" aria-hidden="true" tabindex="-1"></a><span class="st">  }</span></span>
<span id="cb18-69"><a href="#cb18-69" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb18-70"><a href="#cb18-70" aria-hidden="true" tabindex="-1"></a><span class="st">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial values</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>inits <span class="ot">&lt;-</span> <span class="cf">function</span>(){<span class="fu">list</span>(<span class="at">mean.phi =</span> <span class="fu">runif</span>(<span class="dv">1</span>), <span class="at">mean.p =</span> <span class="fu">runif</span>(<span class="dv">1</span>))}</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Parameters monitored</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>params <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"mean.phi"</span>, <span class="st">"mean.p"</span>, <span class="st">"sd.lphi.site"</span>, <span class="st">"sd.lp.site"</span>,</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"sd.lphi.time"</span>, <span class="st">"sd.lp.time"</span>, <span class="st">"mean.phi.site"</span>, <span class="st">"mean.p.site"</span>,</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"mean.phi.time"</span>, <span class="st">"mean.p.time"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># MCMC settings</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co"># na &lt;- 1000 ; ni &lt;- 30000 ; nt &lt;- 10 ; nb &lt;- 20000 ; nc &lt;- 3</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>na <span class="ot">&lt;-</span> <span class="dv">100</span> ; ni <span class="ot">&lt;-</span> <span class="dv">300</span> ; nt <span class="ot">&lt;-</span> <span class="dv">1</span> ; nb <span class="ot">&lt;-</span> <span class="dv">200</span> ; nc <span class="ot">&lt;-</span> <span class="dv">3</span>  <span class="co"># ~~~ for testing</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Call JAGS (ART 192 min), check convergence and summarize posteriors</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>out6 <span class="ot">&lt;-</span> <span class="fu">jags</span>(bdata, inits, params, <span class="st">"cjs6.txt"</span>, <span class="at">n.adapt =</span> na, <span class="at">n.chains =</span> nc,</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">n.thin =</span> nt, <span class="at">n.iter =</span> ni, <span class="at">n.burnin =</span> nb)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Processing function input....... 

Done. 
 
Compiling model graph
   Resolving undeclared variables
   Allocating nodes
Graph information:
   Observed stochastic nodes: 1930
   Unobserved stochastic nodes: 412
   Total graph size: 65699

Initializing model

Adaptive phase, 100 iterations x 3 chains 
If no progress bar appears JAGS has decided not to adapt 
 

 Burn-in phase, 200 iterations x 3 chains 
 

Sampling from joint posterior, 100 iterations x 3 chains 
 

Calculating statistics....... 

Done. </code></pre>
</div>
</div>
</div>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>